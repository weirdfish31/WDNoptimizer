// Created by Microsoft (R) C/C++ Compiler Version 15.00.30729.01 (15374372).
//
// c:\r_stk_v9.2.x\source\lib\release.net\tlhbuilder\agvgt.tli
//
// Wrapper implementations for Win32 type library AgVGT.tlb
// compiler-generated file created 11/23/11 at 05:29:07 - DO NOT EDIT!

#pragma once

namespace AgSTKVgtLib {

//
// interface IAgCrdnContext wrapper method implementations
//

VARIANT_BOOL IAgCrdnContext::GetIsTemplate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTemplate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnTypeInfo wrapper method implementations
//

_bstr_t IAgCrdnTypeInfo::GetTypeDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnTypeInfo::GetTypeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnTypeInfo::GetShortTypeDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ShortTypeDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdn wrapper method implementations
//

enum AgECrdnKind IAgCrdn::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgCrdn::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdn::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdn::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdn::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdn::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL IAgCrdn::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr IAgCrdn::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr IAgCrdn::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t IAgCrdn::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL IAgCrdn::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IAgCrdn::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IAgCrdn::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnInterval wrapper method implementations
//

_variant_t IAgCrdnInterval::GetStart ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t IAgCrdnInterval::GetStop ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Stop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IAgCrdnIntervalCollection wrapper method implementations
//

long IAgCrdnIntervalCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalPtr IAgCrdnIntervalCollection::GetItem ( long Index ) {
    struct IAgCrdnInterval * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalPtr(_result, false);
}

IUnknownPtr IAgCrdnIntervalCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnTimeProperties wrapper method implementations
//

IAgCrdnIntervalCollectionPtr IAgCrdnTimeProperties::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

//
// interface IAgCrdnRefTo wrapper method implementations
//

_bstr_t IAgCrdnRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdnTemplate wrapper method implementations
//

_bstr_t IAgCrdnTemplate::GetClassName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ClassName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdnInstance wrapper method implementations
//

_bstr_t IAgCrdnInstance::GetInstancePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_InstancePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnPtr IAgCrdnInstance::GetTemplate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = get_Template(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

//
// interface IAgCrdnSystemTransformResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnSystemTransformResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemTransformResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnSystemTransformWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnSystemTransformWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemTransformWithRateResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemTransformWithRateResult::GetVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnSystemFindInSystemResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnSystemFindInSystemResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemFindInSystemResult::GetPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemFindInSystemResult::GetVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemFindInSystemResult::GetRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgOrientationPtr IAgCrdnSystemFindInSystemResult::GetOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

//
// interface IAgCrdnSystem wrapper method implementations
//

enum AgECrdnSystemType IAgCrdnSystem::GetType ( ) {
    enum AgECrdnSystemType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnSystemTransformResultPtr IAgCrdnSystem::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnSystem * InputSystem, struct STKUtil::IAgCartesian3Vector * PositionInInputSystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputSystem, PositionInInputSystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr IAgCrdnSystem::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * InputSystem, struct STKUtil::IAgCartesian3Vector * PositionInInputSystem, struct STKUtil::IAgCartesian3Vector * VelocityInInputSystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputSystem, PositionInInputSystem, VelocityInInputSystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

IAgCrdnSystemTransformResultPtr IAgCrdnSystem::TransformTo ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputSystem, PositionInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr IAgCrdnSystem::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem, struct STKUtil::IAgCartesian3Vector * VelocityInMySystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputSystem, PositionInMySystem, VelocityInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

IAgCrdnSystemFindInSystemResultPtr IAgCrdnSystem::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnSystemFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemFindInSystemResultPtr(_result, false);
}

//
// interface IAgCrdnPointLocateInSystemWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPointLocateInSystemWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPointLocateInSystemWithRateResult::GetPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPointLocateInSystemWithRateResult::GetVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPointLocateInSystemResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPointLocateInSystemResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPointLocateInSystemResult::GetPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPoint wrapper method implementations
//

enum AgECrdnPointType IAgCrdnPoint::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr IAgCrdnPoint::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr IAgCrdnPoint::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

//
// interface IAgCrdnPointRefTo wrapper method implementations
//

HRESULT IAgCrdnPointRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnPointRefTo::SetPoint ( struct IAgCrdnPoint * Point ) {
    HRESULT _hr = raw_SetPoint(Point);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnPointPtr IAgCrdnPointRefTo::GetPoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_GetPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

//
// interface IAgCrdnAxesTransformResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAxesTransformResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAxesTransformResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnAxesTransformWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAxesTransformWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAxesTransformWithRateResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAxesTransformWithRateResult::GetVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnAxesFindInAxesWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAxesFindInAxesWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAxesFindInAxesWithRateResult::GetAngularVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_AngularVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgOrientationPtr IAgCrdnAxesFindInAxesWithRateResult::GetOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

//
// interface IAgCrdnAxesFindInAxesResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAxesFindInAxesResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgOrientationPtr IAgCrdnAxesFindInAxesResult::GetOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

//
// interface IAgCrdnAxesLabels wrapper method implementations
//

_bstr_t IAgCrdnAxesLabels::GetLabelX ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesLabels::PutLabelX ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelX(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnAxesLabels::GetLabelY ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesLabels::PutLabelY ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelY(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnAxesLabels::GetLabelZ ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesLabels::PutLabelZ ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelZ(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxes wrapper method implementations
//

enum AgECrdnAxesType IAgCrdnAxes::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr IAgCrdnAxes::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr IAgCrdnAxes::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr IAgCrdnAxes::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr IAgCrdnAxes::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr IAgCrdnAxes::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr IAgCrdnAxes::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr IAgCrdnAxes::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

//
// interface IAgCrdnVectorFindInAxesResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnVectorFindInAxesResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnVectorFindInAxesResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnVectorFindInAxesWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnVectorFindInAxesWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnVectorFindInAxesWithRateResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnVectorFindInAxesWithRateResult::GetRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnVector wrapper method implementations
//

enum AgECrdnVectorType IAgCrdnVector::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr IAgCrdnVector::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr IAgCrdnVector::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

//
// interface IAgCrdnVectorRefTo wrapper method implementations
//

HRESULT IAgCrdnVectorRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnVectorRefTo::SetVector ( struct IAgCrdnVector * Vector ) {
    HRESULT _hr = raw_SetVector(Vector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnVectorPtr IAgCrdnVectorRefTo::GetVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = raw_GetVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

//
// interface IAgCrdnAxesRefTo wrapper method implementations
//

HRESULT IAgCrdnAxesRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnAxesRefTo::SetAxes ( struct IAgCrdnAxes * Axes ) {
    HRESULT _hr = raw_SetAxes(Axes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnAxesPtr IAgCrdnAxesRefTo::GetAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = raw_GetAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface IAgCrdnAngleFindAngleResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAngleFindAngleResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double IAgCrdnAngleFindAngleResult::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnAngleFindAngleWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAngleFindAngleWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double IAgCrdnAngleFindAngleWithRateResult::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double IAgCrdnAngleFindAngleWithRateResult::GetAngleRate ( ) {
    double _result = 0;
    HRESULT _hr = get_AngleRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnAngleFindResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAngleFindResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double IAgCrdnAngleFindResult::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindResult::GetVectorFrom ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorFrom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindResult::GetVectorTo ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorTo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindResult::GetVectorAbout ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorAbout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnAngleFindWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAngleFindWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double IAgCrdnAngleFindWithRateResult::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double IAgCrdnAngleFindWithRateResult::GetAngleRate ( ) {
    double _result = 0;
    HRESULT _hr = get_AngleRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindWithRateResult::GetVectorFrom ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorFrom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindWithRateResult::GetVectorTo ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorTo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindWithRateResult::GetVectorAbout ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorAbout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnAngle wrapper method implementations
//

enum AgECrdnAngleType IAgCrdnAngle::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr IAgCrdnAngle::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr IAgCrdnAngle::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr IAgCrdnAngle::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr IAgCrdnAngle::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

//
// interface IAgCrdnAngleRefTo wrapper method implementations
//

HRESULT IAgCrdnAngleRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnAngleRefTo::SetAngle ( struct IAgCrdnAngle * Angle ) {
    HRESULT _hr = raw_SetAngle(Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnAnglePtr IAgCrdnAngleRefTo::GetAngle ( ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = raw_GetAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

//
// interface IAgCrdnSystemRefTo wrapper method implementations
//

HRESULT IAgCrdnSystemRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnSystemRefTo::SetSystem ( struct IAgCrdnSystem * System ) {
    HRESULT _hr = raw_SetSystem(System);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnSystemPtr IAgCrdnSystemRefTo::GetSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = raw_GetSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

//
// interface IAgCrdnPlaneFindInAxesResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPlaneFindInAxesResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesResult::GetXAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesResult::GetYAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPlaneFindInAxesWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPlaneFindInAxesWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesWithRateResult::GetXAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesWithRateResult::GetXAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesWithRateResult::GetYAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesWithRateResult::GetYAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPlaneFindInSystemResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPlaneFindInSystemResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemResult::GetOriginPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_OriginPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemResult::GetXAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemResult::GetYAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPlaneFindInSystemWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPlaneFindInSystemWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetOriginPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_OriginPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetOriginVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_OriginVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetXAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetXAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetYAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetYAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPlaneLabels wrapper method implementations
//

_bstr_t IAgCrdnPlaneLabels::GetXAxisLabel ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_XAxisLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPlaneLabels::PutXAxisLabel ( _bstr_t pRetVal ) {
    HRESULT _hr = put_XAxisLabel(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnPlaneLabels::GetYAxisLabel ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_YAxisLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPlaneLabels::PutYAxisLabel ( _bstr_t pRetVal ) {
    HRESULT _hr = put_YAxisLabel(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPlane wrapper method implementations
//

enum AgECrdnPlaneType IAgCrdnPlane::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr IAgCrdnPlane::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr IAgCrdnPlane::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr IAgCrdnPlane::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr IAgCrdnPlane::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr IAgCrdnPlane::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

//
// interface IAgCrdnPlaneRefTo wrapper method implementations
//

HRESULT IAgCrdnPlaneRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnPlaneRefTo::SetPlane ( struct IAgCrdnPlane * Plane ) {
    HRESULT _hr = raw_SetPlane(Plane);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnPlanePtr IAgCrdnPlaneRefTo::GetPlane ( ) {
    struct IAgCrdnPlane * _result = 0;
    HRESULT _hr = raw_GetPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlanePtr(_result, false);
}

//
// interface IAgCrdnAxesAlignedAndConstrained wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAxesAlignedAndConstrained::GetAlignmentReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_AlignmentReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnAxesAlignedAndConstrained::GetConstraintReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ConstraintReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

STKUtil::IAgDirectionPtr IAgCrdnAxesAlignedAndConstrained::GetAlignmentDirection ( ) {
    struct STKUtil::IAgDirection * _result = 0;
    HRESULT _hr = get_AlignmentDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgDirectionPtr(_result, false);
}

STKUtil::IAgDirectionPtr IAgCrdnAxesAlignedAndConstrained::GetConstraintDirection ( ) {
    struct STKUtil::IAgDirection * _result = 0;
    HRESULT _hr = get_ConstraintDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgDirectionPtr(_result, false);
}

//
// interface IAgCrdnAxesAngularOffset wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAxesAngularOffset::GetSpinVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SpinVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAngleRefToPtr IAgCrdnAxesAngularOffset::GetRotationAngle ( ) {
    struct IAgCrdnAngleRefTo * _result = 0;
    HRESULT _hr = get_RotationAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnAxesAngularOffset::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

double IAgCrdnAxesAngularOffset::GetFixedOffsetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_FixedOffsetAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesAngularOffset::PutFixedOffsetAngle ( double pRetVal ) {
    HRESULT _hr = put_FixedOffsetAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesFixedAtEpoch wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnAxesFixedAtEpoch::GetSourceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_SourceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnAxesFixedAtEpoch::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_variant_t IAgCrdnAxesFixedAtEpoch::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCrdnAxesFixedAtEpoch::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCentralBody wrapper method implementations
//

_bstr_t IAgCrdnCentralBody::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdnCentralBodyRefTo wrapper method implementations
//

HRESULT IAgCrdnCentralBodyRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnCentralBodyRefTo::SetCentralBody ( struct IAgCrdnCentralBody * CentralBody ) {
    HRESULT _hr = raw_SetCentralBody(CentralBody);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnCentralBodyPtr IAgCrdnCentralBodyRefTo::GetCentralBody ( ) {
    struct IAgCrdnCentralBody * _result = 0;
    HRESULT _hr = raw_GetCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyPtr(_result, false);
}

//
// interface IAgCrdnAxesBPlane wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnAxesBPlane::GetTrajectory ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Trajectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnAxesBPlane::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr IAgCrdnAxesBPlane::GetTargetBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_TargetBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnDirectionType IAgCrdnAxesBPlane::GetDirection ( ) {
    enum AgECrdnDirectionType _result;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesBPlane::PutDirection ( enum AgECrdnDirectionType pRetVal ) {
    HRESULT _hr = put_Direction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesCustomScript wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnAxesCustomScript::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_bstr_t IAgCrdnAxesCustomScript::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesCustomScript::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesAttitudeFile wrapper method implementations
//

_bstr_t IAgCrdnAxesAttitudeFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesAttitudeFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesFixed wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnAxesFixed::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

STKUtil::IAgOrientationPtr IAgCrdnAxesFixed::GetFixedOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_FixedOrientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

//
// interface IAgCrdnAxesModelAttach wrapper method implementations
//

_bstr_t IAgCrdnAxesModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesSpinning wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAxesSpinning::GetSpinVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SpinVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnAxesSpinning::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_variant_t IAgCrdnAxesSpinning::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCrdnAxesSpinning::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnAxesSpinning::GetInitialOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_InitialOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesSpinning::PutInitialOffset ( double pRetVal ) {
    HRESULT _hr = put_InitialOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnAxesSpinning::GetSpinRate ( ) {
    double _result = 0;
    HRESULT _hr = get_SpinRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesSpinning::PutSpinRate ( double pRetVal ) {
    HRESULT _hr = put_SpinRate(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesOnSurface wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnAxesOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnAxesOnSurface::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

VARIANT_BOOL IAgCrdnAxesOnSurface::GetUseMSL ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMSL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesOnSurface::PutUseMSL ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMSL(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesTrajectory wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnAxesTrajectory::GetTrajectoryPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_TrajectoryPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnSystemRefToPtr IAgCrdnAxesTrajectory::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

enum AgECrdnTrajectoryAxesType IAgCrdnAxesTrajectory::GetTrajectoryAxesType ( ) {
    enum AgECrdnTrajectoryAxesType _result;
    HRESULT _hr = get_TrajectoryAxesType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesTrajectory::PutTrajectoryAxesType ( enum AgECrdnTrajectoryAxesType pRetVal ) {
    HRESULT _hr = put_TrajectoryAxesType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCentralBodyCollection wrapper method implementations
//

long IAgCrdnCentralBodyCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgCrdnCentralBodyCollection::GetItem ( long Index ) {
    BSTR _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IUnknownPtr IAgCrdnCentralBodyCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

VARIANT_BOOL IAgCrdnCentralBodyCollection::Add ( _bstr_t CentralBodyName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Add(CentralBodyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgCrdnCentralBodyCollection::Remove ( _bstr_t CentralBodyName ) {
    HRESULT _hr = raw_Remove(CentralBodyName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnAxesLagrangeLibration wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnAxesLagrangeLibration::GetPrimaryCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_PrimaryCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnLagrangeLibrationPointType IAgCrdnAxesLagrangeLibration::GetPointType ( ) {
    enum AgECrdnLagrangeLibrationPointType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesLagrangeLibration::PutPointType ( enum AgECrdnLagrangeLibrationPointType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCentralBodyCollectionPtr IAgCrdnAxesLagrangeLibration::GetSecondaryCentralBodies ( ) {
    struct IAgCrdnCentralBodyCollection * _result = 0;
    HRESULT _hr = get_SecondaryCentralBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyCollectionPtr(_result, false);
}

//
// interface IAgCrdnAngleBetweenVectors wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAngleBetweenVectors::GetFromVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_FromVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnAngleBetweenVectors::GetToVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ToVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

//
// interface IAgCrdnAngleBetweenPlanes wrapper method implementations
//

IAgCrdnPlaneRefToPtr IAgCrdnAngleBetweenPlanes::GetFromPlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_FromPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnAngleBetweenPlanes::GetToPlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ToPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface IAgCrdnAngleDihedral wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAngleDihedral::GetFromVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_FromVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnAngleDihedral::GetToVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ToVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnAngleDihedral::GetPoleAbout ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_PoleAbout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL IAgCrdnAngleDihedral::GetCounterClockwiseRotation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CounterClockwiseRotation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAngleDihedral::PutCounterClockwiseRotation ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_CounterClockwiseRotation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnAngleDihedral::GetSignedAngle ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SignedAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAngleDihedral::PutSignedAngle ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_SignedAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAngleRotation wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnAngleRotation::GetFromAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_FromAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnAngleRotation::GetToAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ToAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

enum AgECrdnDisplayAxisSelector IAgCrdnAngleRotation::GetReferenceDirection ( ) {
    enum AgECrdnDisplayAxisSelector _result;
    HRESULT _hr = get_ReferenceDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAngleRotation::PutReferenceDirection ( enum AgECrdnDisplayAxisSelector pRetVal ) {
    HRESULT _hr = put_ReferenceDirection(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAngleToPlane wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAngleToPlane::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnAngleToPlane::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

enum AgECrdnSignedAngleType IAgCrdnAngleToPlane::GetSigned ( ) {
    enum AgECrdnSignedAngleType _result;
    HRESULT _hr = get_Signed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAngleToPlane::PutSigned ( enum AgECrdnSignedAngleType pRetVal ) {
    HRESULT _hr = put_Signed(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPlaneNormal wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnPlaneNormal::GetNormalVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_NormalVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnPlaneNormal::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPlaneNormal::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface IAgCrdnPlaneQuadrant wrapper method implementations
//

IAgCrdnSystemRefToPtr IAgCrdnPlaneQuadrant::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

enum AgECrdnQuadrantType IAgCrdnPlaneQuadrant::GetQuadrant ( ) {
    enum AgECrdnQuadrantType _result;
    HRESULT _hr = get_Quadrant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPlaneQuadrant::PutQuadrant ( enum AgECrdnQuadrantType pRetVal ) {
    HRESULT _hr = put_Quadrant(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPlaneTrajectory wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnPlaneTrajectory::GetPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Point(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnSystemRefToPtr IAgCrdnPlaneTrajectory::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

double IAgCrdnPlaneTrajectory::GetRotationOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPlaneTrajectory::PutRotationOffset ( double pRetVal ) {
    HRESULT _hr = put_RotationOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPlaneTriad wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnPlaneTriad::GetPointA ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_PointA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPlaneTriad::GetPointB ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_PointB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPlaneTriad::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

double IAgCrdnPlaneTriad::GetRotationOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPlaneTriad::PutRotationOffset ( double pRetVal ) {
    HRESULT _hr = put_RotationOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointBPlane wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnPointBPlane::GetTargetBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_TargetBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointBPlane::GetTrajectory ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Trajectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnPointBPlaneType IAgCrdnPointBPlane::GetPointType ( ) {
    enum AgECrdnPointBPlaneType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointBPlane::PutPointType ( enum AgECrdnPointBPlaneType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnDirectionType IAgCrdnPointBPlane::GetDirection ( ) {
    enum AgECrdnDirectionType _result;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointBPlane::PutDirection ( enum AgECrdnDirectionType pRetVal ) {
    HRESULT _hr = put_Direction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointFile wrapper method implementations
//

_bstr_t IAgCrdnPointFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPointFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointFixedInSystem wrapper method implementations
//

IAgCrdnSystemRefToPtr IAgCrdnPointFixedInSystem::GetReference ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_Reference(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

STKUtil::IAgPositionPtr IAgCrdnPointFixedInSystem::GetFixedPoint ( ) {
    struct STKUtil::IAgPosition * _result = 0;
    HRESULT _hr = get_FixedPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgPositionPtr(_result, false);
}

//
// interface IAgCrdnPointGrazing wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnPointGrazing::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointGrazing::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnPointGrazing::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double IAgCrdnPointGrazing::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointGrazing::PutAltitude ( double pRetVal ) {
    HRESULT _hr = put_Altitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointGlint wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnPointGlint::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointGlint::GetSourcePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_SourcePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointGlint::GetObserverPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ObserverPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface IAgCrdnPointCovarianceGrazing wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnPointCovarianceGrazing::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnPointCovarianceGrazing::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

_bstr_t IAgCrdnPointCovarianceGrazing::GetTargetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TargetName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPointCovarianceGrazing::PutTargetName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_TargetName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnPointCovarianceGrazing::GetDistance ( ) {
    double _result = 0;
    HRESULT _hr = get_Distance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCovarianceGrazing::PutDistance ( double pRetVal ) {
    HRESULT _hr = put_Distance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnPointCovarianceGrazing::GetProbability ( ) {
    double _result = 0;
    HRESULT _hr = get_Probability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCovarianceGrazing::PutProbability ( double pRetVal ) {
    HRESULT _hr = put_Probability(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnPointCovarianceGrazing::GetScale ( ) {
    double _result = 0;
    HRESULT _hr = get_Scale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCovarianceGrazing::PutScale ( double pRetVal ) {
    HRESULT _hr = put_Scale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnPointCovarianceGrazing::GetUseProbability ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseProbability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCovarianceGrazing::PutUseProbability ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseProbability(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointPlaneIntersection wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnPointPlaneIntersection::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnPointPlaneIntersection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointPlaneIntersection::GetOriginPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_OriginPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface IAgCrdnPointOnSurface wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnPointOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointOnSurface::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnReferenceShapeType IAgCrdnPointOnSurface::GetReferenceShape ( ) {
    enum AgECrdnReferenceShapeType _result;
    HRESULT _hr = get_ReferenceShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointOnSurface::PutReferenceShape ( enum AgECrdnReferenceShapeType pRetVal ) {
    HRESULT _hr = put_ReferenceShape(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSurfaceType IAgCrdnPointOnSurface::GetSurfaceType ( ) {
    enum AgECrdnSurfaceType _result;
    HRESULT _hr = get_SurfaceType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointOnSurface::PutSurfaceType ( enum AgECrdnSurfaceType pRetVal ) {
    HRESULT _hr = put_SurfaceType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointModelAttach wrapper method implementations
//

_bstr_t IAgCrdnPointModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPointModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnPointModelAttach::GetUseScale ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseScale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointModelAttach::PutUseScale ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseScale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointPlaneProjection wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnPointPlaneProjection::GetSourcePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_SourcePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnPointPlaneProjection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface IAgCrdnPointLagrangeLibration wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnPointLagrangeLibration::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnLagrangeLibrationPointType IAgCrdnPointLagrangeLibration::GetPointType ( ) {
    enum AgECrdnLagrangeLibrationPointType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointLagrangeLibration::PutPointType ( enum AgECrdnLagrangeLibrationPointType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCentralBodyCollectionPtr IAgCrdnPointLagrangeLibration::GetSecondaryCentralBodies ( ) {
    struct IAgCrdnCentralBodyCollection * _result = 0;
    HRESULT _hr = get_SecondaryCentralBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyCollectionPtr(_result, false);
}

//
// interface IAgCrdnSystemAssembled wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnSystemAssembled::GetOriginPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_OriginPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnSystemAssembled::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

//
// interface IAgCrdnLLAPosition wrapper method implementations
//

double IAgCrdnLLAPosition::GetLatitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Latitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLLAPosition::PutLatitude ( double pRetVal ) {
    HRESULT _hr = put_Latitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnLLAPosition::GetLongitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Longitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLLAPosition::PutLongitude ( double pRetVal ) {
    HRESULT _hr = put_Longitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnLLAPosition::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLLAPosition::PutAltitude ( double pRetVal ) {
    HRESULT _hr = put_Altitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnSystemOnSurface wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnSystemOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

double IAgCrdnSystemOnSurface::GetAzimuthAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_AzimuthAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSystemOnSurface::PutAzimuthAngle ( double pRetVal ) {
    HRESULT _hr = put_AzimuthAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnSystemOnSurface::GetUseMSL ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMSL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSystemOnSurface::PutUseMSL ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMSL(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnLLAPositionPtr IAgCrdnSystemOnSurface::GetPosition ( ) {
    struct IAgCrdnLLAPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnLLAPositionPtr(_result, false);
}

//
// interface IAgCrdnVectorAngleRate wrapper method implementations
//

IAgCrdnAngleRefToPtr IAgCrdnVectorAngleRate::GetAngle ( ) {
    struct IAgCrdnAngleRefTo * _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorApoapsis wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnVectorApoapsis::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorApoapsis::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory IAgCrdnVectorApoapsis::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorApoapsis::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorFixedAtEpoch wrapper method implementations
//

_variant_t IAgCrdnVectorFixedAtEpoch::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCrdnVectorFixedAtEpoch::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorRefToPtr IAgCrdnVectorFixedAtEpoch::GetSourceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SourceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnVectorFixedAtEpoch::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorAngularVelocity wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnVectorAngularVelocity::GetAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_Axes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnVectorAngularVelocity::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorConing wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorConing::GetAboutVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_AboutVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnVectorConing::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double IAgCrdnVectorConing::GetStartClockAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_StartClockAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorConing::PutStartClockAngle ( double pRetVal ) {
    HRESULT _hr = put_StartClockAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorConing::GetStopClockAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_StopClockAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorConing::PutStopClockAngle ( double pRetVal ) {
    HRESULT _hr = put_StopClockAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgCrdnVectorConing::GetStartEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_StartEpoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCrdnVectorConing::PutStartEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_StartEpoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorConing::GetClockAngleRate ( ) {
    double _result = 0;
    HRESULT _hr = get_ClockAngleRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorConing::PutClockAngleRate ( double pRetVal ) {
    HRESULT _hr = put_ClockAngleRate(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSweepMode IAgCrdnVectorConing::GetMode ( ) {
    enum AgECrdnSweepMode _result;
    HRESULT _hr = get_Mode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorConing::PutMode ( enum AgECrdnSweepMode pRetVal ) {
    HRESULT _hr = put_Mode(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorCross wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorCross::GetFrom ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_From(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnVectorCross::GetTo ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_To(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorCustomScript wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnVectorCustomScript::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_bstr_t IAgCrdnVectorCustomScript::GetScriptFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ScriptFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorCustomScript::PutScriptFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ScriptFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnVectorCustomScript::GetInitializationScriptFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_InitializationScriptFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorCustomScript::PutInitializationScriptFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_InitializationScriptFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorDerivative wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorDerivative::GetVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnVectorDerivative::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorDisplacement wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnVectorDisplacement::GetOrigin ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Origin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorDisplacement::GetDestination ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Destination(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorDisplacement::GetApparent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Apparent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorDisplacement::PutApparent ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_Apparent(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVectorDisplacement::GetIgnoreAbberation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IgnoreAbberation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorDisplacement::PutIgnoreAbberation ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IgnoreAbberation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense IAgCrdnVectorDisplacement::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorDisplacement::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemRefToPtr IAgCrdnVectorDisplacement::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorTwoPlanesIntersection wrapper method implementations
//

IAgCrdnPlaneRefToPtr IAgCrdnVectorTwoPlanesIntersection::GetPlaneA ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_PlaneA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnVectorTwoPlanesIntersection::GetPlaneB ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_PlaneB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorModelAttach wrapper method implementations
//

_bstr_t IAgCrdnVectorModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorProjection wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorProjection::GetSource ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_Source(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnVectorProjection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorScaled wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorScaled::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double IAgCrdnVectorScaled::GetScale ( ) {
    double _result = 0;
    HRESULT _hr = get_Scale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScaled::PutScale ( double pRetVal ) {
    HRESULT _hr = put_Scale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVectorScaled::GetIsNormalized ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNormalized(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScaled::PutIsNormalized ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IsNormalized(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorEccentricity wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorEccentricity::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorEccentricity::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory IAgCrdnVectorEccentricity::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorEccentricity::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorFixedInAxes wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnVectorFixedInAxes::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

STKUtil::IAgPositionPtr IAgCrdnVectorFixedInAxes::GetPosition ( ) {
    struct STKUtil::IAgPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgPositionPtr(_result, false);
}

//
// interface IAgCrdnVectorLineOfNodes wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorLineOfNodes::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorLineOfNodes::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorOrbitAngularMomentum wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorOrbitAngularMomentum::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorOrbitAngularMomentum::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory IAgCrdnVectorOrbitAngularMomentum::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorOrbitAngularMomentum::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorOrbitNormal wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorOrbitNormal::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorOrbitNormal::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory IAgCrdnVectorOrbitNormal::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorOrbitNormal::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorPeriapsis wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorPeriapsis::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorPeriapsis::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory IAgCrdnVectorPeriapsis::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorPeriapsis::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorReflection wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorReflection::GetIncomingVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_IncomingVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorReflection::GetUseOppositeOfSelectedVector ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseOppositeOfSelectedVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorReflection::PutUseOppositeOfSelectedVector ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseOppositeOfSelectedVector(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorRefToPtr IAgCrdnVectorReflection::GetNormalVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_NormalVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorReflection::GetAllowReflectionsOnBackside ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowReflectionsOnBackside(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorReflection::PutAllowReflectionsOnBackside ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_AllowReflectionsOnBackside(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorReflection::GetScaleFactor ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorReflection::PutScaleFactor ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactor(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorDirectionToStar wrapper method implementations
//

_bstr_t IAgCrdnVectorDirectionToStar::GetSelectedStar ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SelectedStar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorDirectionToStar::PutSelectedStar ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SelectedStar(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorFactory wrapper method implementations
//

IAgCrdnVectorPtr IAgCrdnVectorFactory::Create ( _bstr_t VectorName, _bstr_t Description, enum AgECrdnVectorType VectorType ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = raw_Create(VectorName, Description, VectorType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorFactory::IsTypeSupported ( enum AgECrdnVectorType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorDisplacementPtr IAgCrdnVectorFactory::CreateDisplacementVector ( _bstr_t VectorName, struct IAgCrdnPoint * OriginPoint, struct IAgCrdnPoint * DestPoint ) {
    struct IAgCrdnVectorDisplacement * _result = 0;
    HRESULT _hr = raw_CreateDisplacementVector(VectorName, OriginPoint, DestPoint, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorDisplacementPtr(_result, false);
}

IAgCrdnVectorCrossPtr IAgCrdnVectorFactory::CreateCrossVector ( _bstr_t VectorName, struct IAgCrdnVector * VectorTo, struct IAgCrdnVector * VectorFrom ) {
    struct IAgCrdnVectorCross * _result = 0;
    HRESULT _hr = raw_CreateCrossVector(VectorName, VectorTo, VectorFrom, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorCrossPtr(_result, false);
}

//
// interface IAgCrdnAxesFactory wrapper method implementations
//

IAgCrdnAxesPtr IAgCrdnAxesFactory::Create ( _bstr_t AxesName, _bstr_t Description, enum AgECrdnAxesType AxesType ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = raw_Create(AxesName, Description, AxesType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

VARIANT_BOOL IAgCrdnAxesFactory::IsTypeSupported ( enum AgECrdnAxesType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnSystemFactory wrapper method implementations
//

IAgCrdnSystemPtr IAgCrdnSystemFactory::Create ( _bstr_t SystemName, _bstr_t Description, enum AgECrdnSystemType SystemType ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = raw_Create(SystemName, Description, SystemType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

VARIANT_BOOL IAgCrdnSystemFactory::IsTypeSupported ( enum AgECrdnSystemType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnPointFactory wrapper method implementations
//

IAgCrdnPointPtr IAgCrdnPointFactory::Create ( _bstr_t PointName, _bstr_t Description, enum AgECrdnPointType PointType ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_Create(PointName, Description, PointType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

VARIANT_BOOL IAgCrdnPointFactory::IsTypeSupported ( enum AgECrdnPointType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnPlaneFactory wrapper method implementations
//

IAgCrdnPlanePtr IAgCrdnPlaneFactory::Create ( _bstr_t PlaneName, _bstr_t Description, enum AgECrdnPlaneType PlaneType ) {
    struct IAgCrdnPlane * _result = 0;
    HRESULT _hr = raw_Create(PlaneName, Description, PlaneType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlanePtr(_result, false);
}

VARIANT_BOOL IAgCrdnPlaneFactory::IsTypeSupported ( enum AgECrdnPlaneType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnAngleFactory wrapper method implementations
//

IAgCrdnAnglePtr IAgCrdnAngleFactory::Create ( _bstr_t AngleName, _bstr_t Description, enum AgECrdnAngleType AngleType ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = raw_Create(AngleName, Description, AngleType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

VARIANT_BOOL IAgCrdnAngleFactory::IsTypeSupported ( enum AgECrdnAngleType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnVectorGroup wrapper method implementations
//

HRESULT IAgCrdnVectorGroup::Remove ( _bstr_t VectorName ) {
    HRESULT _hr = raw_Remove(VectorName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnVectorGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnVectorGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFactoryPtr IAgCrdnVectorGroup::GetFactory ( ) {
    struct IAgCrdnVectorFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFactoryPtr(_result, false);
}

IAgCrdnVectorPtr IAgCrdnVectorGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IUnknownPtr IAgCrdnVectorGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnPointGroup wrapper method implementations
//

HRESULT IAgCrdnPointGroup::Remove ( _bstr_t PointName ) {
    HRESULT _hr = raw_Remove(PointName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnPointGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnPointGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnPointGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointFactoryPtr IAgCrdnPointGroup::GetFactory ( ) {
    struct IAgCrdnPointFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointFactoryPtr(_result, false);
}

IAgCrdnPointPtr IAgCrdnPointGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

IUnknownPtr IAgCrdnPointGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnAngleGroup wrapper method implementations
//

HRESULT IAgCrdnAngleGroup::Remove ( _bstr_t AngleName ) {
    HRESULT _hr = raw_Remove(AngleName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnAngleGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnAngleGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnAngleGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFactoryPtr IAgCrdnAngleGroup::GetFactory ( ) {
    struct IAgCrdnAngleFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFactoryPtr(_result, false);
}

IAgCrdnAnglePtr IAgCrdnAngleGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

IUnknownPtr IAgCrdnAngleGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnAxesGroup wrapper method implementations
//

HRESULT IAgCrdnAxesGroup::Remove ( _bstr_t AxesName ) {
    HRESULT _hr = raw_Remove(AxesName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnAxesGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnAxesGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnAxesGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFactoryPtr IAgCrdnAxesGroup::GetFactory ( ) {
    struct IAgCrdnAxesFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFactoryPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnAxesGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IUnknownPtr IAgCrdnAxesGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnPlaneGroup wrapper method implementations
//

HRESULT IAgCrdnPlaneGroup::Remove ( _bstr_t PlaneName ) {
    HRESULT _hr = raw_Remove(PlaneName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnPlaneGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnPlaneGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnPlaneGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFactoryPtr IAgCrdnPlaneGroup::GetFactory ( ) {
    struct IAgCrdnPlaneFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFactoryPtr(_result, false);
}

IAgCrdnPlanePtr IAgCrdnPlaneGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnPlane * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlanePtr(_result, false);
}

IUnknownPtr IAgCrdnPlaneGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnSystemGroup wrapper method implementations
//

HRESULT IAgCrdnSystemGroup::Remove ( _bstr_t SystemName ) {
    HRESULT _hr = raw_Remove(SystemName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnSystemGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnSystemGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnSystemGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnSystemFactoryPtr IAgCrdnSystemGroup::GetFactory ( ) {
    struct IAgCrdnSystemFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemFactoryPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnSystemGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IUnknownPtr IAgCrdnSystemGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnWellKnownEarthSystems wrapper method implementations
//

IAgCrdnSystemPtr IAgCrdnWellKnownEarthSystems::GetFixed ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownEarthSystems::GetICRF ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownEarthSystems::GetInertial ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

//
// interface IAgCrdnWellKnownSunSystems wrapper method implementations
//

IAgCrdnSystemPtr IAgCrdnWellKnownSunSystems::GetFixed ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownSunSystems::GetICRF ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownSunSystems::GetInertial ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownSunSystems::GetJ2000 ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownSunSystems::GetBarycenter ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Barycenter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

//
// interface IAgCrdnWellKnownSystems wrapper method implementations
//

IAgCrdnWellKnownEarthSystemsPtr IAgCrdnWellKnownSystems::GetEarth ( ) {
    struct IAgCrdnWellKnownEarthSystems * _result = 0;
    HRESULT _hr = get_Earth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownEarthSystemsPtr(_result, false);
}

IAgCrdnWellKnownSunSystemsPtr IAgCrdnWellKnownSystems::GetSun ( ) {
    struct IAgCrdnWellKnownSunSystems * _result = 0;
    HRESULT _hr = get_Sun(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSunSystemsPtr(_result, false);
}

//
// interface IAgCrdnWellKnownEarthAxes wrapper method implementations
//

IAgCrdnAxesPtr IAgCrdnWellKnownEarthAxes::GetFixed ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownEarthAxes::GetICRF ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownEarthAxes::GetInertial ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownEarthAxes::GetJ2000 ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface IAgCrdnWellKnownSunAxes wrapper method implementations
//

IAgCrdnAxesPtr IAgCrdnWellKnownSunAxes::GetFixed ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownSunAxes::GetICRF ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownSunAxes::GetInertial ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownSunAxes::GetJ2000 ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface IAgCrdnWellKnownAxes wrapper method implementations
//

IAgCrdnWellKnownEarthAxesPtr IAgCrdnWellKnownAxes::GetEarth ( ) {
    struct IAgCrdnWellKnownEarthAxes * _result = 0;
    HRESULT _hr = get_Earth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownEarthAxesPtr(_result, false);
}

IAgCrdnWellKnownSunAxesPtr IAgCrdnWellKnownAxes::GetSun ( ) {
    struct IAgCrdnWellKnownSunAxes * _result = 0;
    HRESULT _hr = get_Sun(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSunAxesPtr(_result, false);
}

//
// interface IAgCrdnProvider wrapper method implementations
//

IAgCrdnVectorGroupPtr IAgCrdnProvider::GetVectors ( ) {
    struct IAgCrdnVectorGroup * _result = 0;
    HRESULT _hr = get_Vectors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorGroupPtr(_result, false);
}

IAgCrdnPointGroupPtr IAgCrdnProvider::GetPoints ( ) {
    struct IAgCrdnPointGroup * _result = 0;
    HRESULT _hr = get_Points(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointGroupPtr(_result, false);
}

IAgCrdnAngleGroupPtr IAgCrdnProvider::GetAngles ( ) {
    struct IAgCrdnAngleGroup * _result = 0;
    HRESULT _hr = get_Angles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleGroupPtr(_result, false);
}

IAgCrdnAxesGroupPtr IAgCrdnProvider::GetAxes ( ) {
    struct IAgCrdnAxesGroup * _result = 0;
    HRESULT _hr = get_Axes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesGroupPtr(_result, false);
}

IAgCrdnPlaneGroupPtr IAgCrdnProvider::GetPlanes ( ) {
    struct IAgCrdnPlaneGroup * _result = 0;
    HRESULT _hr = get_Planes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneGroupPtr(_result, false);
}

IAgCrdnSystemGroupPtr IAgCrdnProvider::GetSystems ( ) {
    struct IAgCrdnSystemGroup * _result = 0;
    HRESULT _hr = get_Systems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemGroupPtr(_result, false);
}

IAgCrdnWellKnownSystemsPtr IAgCrdnProvider::GetWellKnownSystems ( ) {
    struct IAgCrdnWellKnownSystems * _result = 0;
    HRESULT _hr = get_WellKnownSystems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSystemsPtr(_result, false);
}

IAgCrdnWellKnownAxesPtr IAgCrdnProvider::GetWellKnownAxes ( ) {
    struct IAgCrdnWellKnownAxes * _result = 0;
    HRESULT _hr = get_WellKnownAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownAxesPtr(_result, false);
}

//
// interface IAgCrdnRootSettings wrapper method implementations
//

VARIANT_BOOL IAgCrdnRootSettings::GetForce3DNotify ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Force3DNotify(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnRootSettings::PutForce3DNotify ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_Force3DNotify(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnRoot wrapper method implementations
//

IAgCrdnProviderPtr IAgCrdnRoot::GetTemplateProvider ( _bstr_t ClassName ) {
    struct IAgCrdnProvider * _result = 0;
    HRESULT _hr = raw_GetTemplateProvider(ClassName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnProviderPtr(_result, false);
}

IAgCrdnProviderPtr IAgCrdnRoot::GetProvider ( _bstr_t InstPath ) {
    struct IAgCrdnProvider * _result = 0;
    HRESULT _hr = raw_GetProvider(InstPath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnProviderPtr(_result, false);
}

IAgCrdnWellKnownSystemsPtr IAgCrdnRoot::GetWellKnownSystems ( ) {
    struct IAgCrdnWellKnownSystems * _result = 0;
    HRESULT _hr = get_WellKnownSystems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSystemsPtr(_result, false);
}

IAgCrdnWellKnownAxesPtr IAgCrdnRoot::GetWellKnownAxes ( ) {
    struct IAgCrdnWellKnownAxes * _result = 0;
    HRESULT _hr = get_WellKnownAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownAxesPtr(_result, false);
}

IAgCrdnRootSettingsPtr IAgCrdnRoot::GetSettings ( ) {
    struct IAgCrdnRootSettings * _result = 0;
    HRESULT _hr = get_Settings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnRootSettingsPtr(_result, false);
}

//
// interface IAgCrdnMethodCallResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnMethodCallResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdn wrapper method implementations
//

enum AgECrdnKind _IAgCrdn::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdn::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdn::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdn::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdn::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdn::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdn::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdn::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdn::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdn::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdn::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdn::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdn::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnTypeInfo wrapper method implementations
//

_bstr_t _IAgCrdnTypeInfo::GetTypeDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnTypeInfo::GetTypeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnTypeInfo::GetShortTypeDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ShortTypeDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface _IAgCrdnTemplate wrapper method implementations
//

VARIANT_BOOL _IAgCrdnTemplate::GetIsTemplate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTemplate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnTemplate::GetClassName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ClassName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface _IAgCrdnInstance wrapper method implementations
//

VARIANT_BOOL _IAgCrdnInstance::GetIsTemplate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTemplate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnInstance::GetInstancePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_InstancePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnPtr _IAgCrdnInstance::GetTemplate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = get_Template(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

//
// interface _IAgCrdnPointRefTo wrapper method implementations
//

_bstr_t _IAgCrdnPointRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnPointRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointRefTo::SetPoint ( struct IAgCrdnPoint * Point ) {
    HRESULT _hr = raw_SetPoint(Point);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnPointPtr _IAgCrdnPointRefTo::GetPoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_GetPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

//
// interface _IAgCrdnVectorRefTo wrapper method implementations
//

_bstr_t _IAgCrdnVectorRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnVectorRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorRefTo::SetVector ( struct IAgCrdnVector * Vector ) {
    HRESULT _hr = raw_SetVector(Vector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnVectorPtr _IAgCrdnVectorRefTo::GetVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = raw_GetVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

//
// interface _IAgCrdnAxesRefTo wrapper method implementations
//

_bstr_t _IAgCrdnAxesRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnAxesRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesRefTo::SetAxes ( struct IAgCrdnAxes * Axes ) {
    HRESULT _hr = raw_SetAxes(Axes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnAxesPtr _IAgCrdnAxesRefTo::GetAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = raw_GetAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface _IAgCrdnAngleRefTo wrapper method implementations
//

_bstr_t _IAgCrdnAngleRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnAngleRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAngleRefTo::SetAngle ( struct IAgCrdnAngle * Angle ) {
    HRESULT _hr = raw_SetAngle(Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnAnglePtr _IAgCrdnAngleRefTo::GetAngle ( ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = raw_GetAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

//
// interface _IAgCrdnSystemRefTo wrapper method implementations
//

_bstr_t _IAgCrdnSystemRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnSystemRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnSystemRefTo::SetSystem ( struct IAgCrdnSystem * System ) {
    HRESULT _hr = raw_SetSystem(System);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnSystemPtr _IAgCrdnSystemRefTo::GetSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = raw_GetSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

//
// interface _IAgCrdnPlaneRefTo wrapper method implementations
//

_bstr_t _IAgCrdnPlaneRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnPlaneRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPlaneRefTo::SetPlane ( struct IAgCrdnPlane * Plane ) {
    HRESULT _hr = raw_SetPlane(Plane);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnPlanePtr _IAgCrdnPlaneRefTo::GetPlane ( ) {
    struct IAgCrdnPlane * _result = 0;
    HRESULT _hr = raw_GetPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlanePtr(_result, false);
}

//
// interface _IAgCrdnVector wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVector::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVector::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVector::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVector::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVector::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVector::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVector::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVector::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVector::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVector::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVector::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVector::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVector::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVector::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVector::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVector::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVector::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

//
// interface _IAgCrdnAxesLabels wrapper method implementations
//

_bstr_t _IAgCrdnAxesLabels::GetLabelX ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesLabels::PutLabelX ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelX(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesLabels::GetLabelY ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesLabels::PutLabelY ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelY(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesLabels::GetLabelZ ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesLabels::PutLabelZ ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelZ(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAxes wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxes::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxes::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxes::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxes::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxes::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxes::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxes::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxes::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxes::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxes::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxes::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxes::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxes::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxes::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxes::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxes::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxes::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxes::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxes::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxes::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxes::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxes::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

//
// interface _IAgCrdnPoint wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPoint::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPoint::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPoint::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPoint::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPoint::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPoint::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPoint::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPoint::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPoint::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPoint::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPoint::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPoint::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPoint::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPoint::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPoint::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPoint::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPoint::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

//
// interface _IAgCrdnSystem wrapper method implementations
//

enum AgECrdnKind _IAgCrdnSystem::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnSystem::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnSystem::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnSystem::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystem::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystem::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystem::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnSystem::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnSystem::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnSystem::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystem::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystem::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystem::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnSystem::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnSystemType _IAgCrdnSystem::GetType ( ) {
    enum AgECrdnSystemType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnSystemTransformResultPtr _IAgCrdnSystem::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnSystem * InputSystem, struct STKUtil::IAgCartesian3Vector * PositionInInputSystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputSystem, PositionInInputSystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr _IAgCrdnSystem::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * InputSystem, struct STKUtil::IAgCartesian3Vector * PositionInInputSystem, struct STKUtil::IAgCartesian3Vector * VelocityInInputSystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputSystem, PositionInInputSystem, VelocityInInputSystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

IAgCrdnSystemTransformResultPtr _IAgCrdnSystem::TransformTo ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputSystem, PositionInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr _IAgCrdnSystem::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem, struct STKUtil::IAgCartesian3Vector * VelocityInMySystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputSystem, PositionInMySystem, VelocityInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

IAgCrdnSystemFindInSystemResultPtr _IAgCrdnSystem::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnSystemFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemFindInSystemResultPtr(_result, false);
}

//
// interface _IAgCrdnAngle wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngle::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngle::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngle::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngle::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngle::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngle::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngle::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngle::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngle::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngle::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngle::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngle::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngle::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngle::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngle::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngle::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngle::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngle::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngle::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

//
// interface _IAgCrdnPlaneLabels wrapper method implementations
//

_bstr_t _IAgCrdnPlaneLabels::GetXAxisLabel ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_XAxisLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneLabels::PutXAxisLabel ( _bstr_t pRetVal ) {
    HRESULT _hr = put_XAxisLabel(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlaneLabels::GetYAxisLabel ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_YAxisLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneLabels::PutYAxisLabel ( _bstr_t pRetVal ) {
    HRESULT _hr = put_YAxisLabel(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPlane wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPlane::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPlane::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlane::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlane::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlane::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlane::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlane::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPlane::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPlane::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPlane::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlane::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlane::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlane::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPlane::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPlaneType _IAgCrdnPlane::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr _IAgCrdnPlane::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr _IAgCrdnPlane::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr _IAgCrdnPlane::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr _IAgCrdnPlane::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr _IAgCrdnPlane::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

//
// interface _IAgCrdnAxesAlignedAndConstrained wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesAlignedAndConstrained::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesAlignedAndConstrained::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesAlignedAndConstrained::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesAlignedAndConstrained::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAlignedAndConstrained::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAlignedAndConstrained::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAlignedAndConstrained::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesAlignedAndConstrained::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesAlignedAndConstrained::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesAlignedAndConstrained::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAlignedAndConstrained::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAlignedAndConstrained::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAlignedAndConstrained::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesAlignedAndConstrained::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesAlignedAndConstrained::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesAlignedAndConstrained::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesAlignedAndConstrained::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesAlignedAndConstrained::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesAlignedAndConstrained::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesAlignedAndConstrained::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesAlignedAndConstrained::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesAlignedAndConstrained::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAxesAlignedAndConstrained::GetAlignmentReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_AlignmentReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAxesAlignedAndConstrained::GetConstraintReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ConstraintReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

STKUtil::IAgDirectionPtr _IAgCrdnAxesAlignedAndConstrained::GetAlignmentDirection ( ) {
    struct STKUtil::IAgDirection * _result = 0;
    HRESULT _hr = get_AlignmentDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgDirectionPtr(_result, false);
}

STKUtil::IAgDirectionPtr _IAgCrdnAxesAlignedAndConstrained::GetConstraintDirection ( ) {
    struct STKUtil::IAgDirection * _result = 0;
    HRESULT _hr = get_ConstraintDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgDirectionPtr(_result, false);
}

//
// interface _IAgCrdnAxesAngularOffset wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesAngularOffset::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesAngularOffset::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesAngularOffset::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesAngularOffset::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAngularOffset::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAngularOffset::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAngularOffset::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesAngularOffset::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesAngularOffset::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesAngularOffset::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAngularOffset::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAngularOffset::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAngularOffset::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesAngularOffset::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesAngularOffset::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesAngularOffset::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesAngularOffset::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesAngularOffset::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesAngularOffset::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesAngularOffset::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesAngularOffset::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesAngularOffset::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAxesAngularOffset::GetSpinVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SpinVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAngleRefToPtr _IAgCrdnAxesAngularOffset::GetRotationAngle ( ) {
    struct IAgCrdnAngleRefTo * _result = 0;
    HRESULT _hr = get_RotationAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesAngularOffset::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

double _IAgCrdnAxesAngularOffset::GetFixedOffsetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_FixedOffsetAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesAngularOffset::PutFixedOffsetAngle ( double pRetVal ) {
    HRESULT _hr = put_FixedOffsetAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAxesFixedAtEpoch wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesFixedAtEpoch::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesFixedAtEpoch::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesFixedAtEpoch::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesFixedAtEpoch::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesFixedAtEpoch::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesFixedAtEpoch::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFixedAtEpoch::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesFixedAtEpoch::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesFixedAtEpoch::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesFixedAtEpoch::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFixedAtEpoch::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesFixedAtEpoch::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesFixedAtEpoch::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesFixedAtEpoch::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesFixedAtEpoch::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesFixedAtEpoch::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesFixedAtEpoch::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesFixedAtEpoch::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesFixedAtEpoch::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesFixedAtEpoch::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesFixedAtEpoch::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesFixedAtEpoch::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesFixedAtEpoch::GetSourceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_SourceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesFixedAtEpoch::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_variant_t _IAgCrdnAxesFixedAtEpoch::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCrdnAxesFixedAtEpoch::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAxesBPlane wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesBPlane::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesBPlane::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesBPlane::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesBPlane::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesBPlane::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesBPlane::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesBPlane::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesBPlane::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesBPlane::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesBPlane::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesBPlane::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesBPlane::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesBPlane::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesBPlane::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesBPlane::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesBPlane::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesBPlane::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesBPlane::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesBPlane::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesBPlane::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesBPlane::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesBPlane::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnAxesBPlane::GetTrajectory ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Trajectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAxesBPlane::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnAxesBPlane::GetTargetBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_TargetBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnDirectionType _IAgCrdnAxesBPlane::GetDirection ( ) {
    enum AgECrdnDirectionType _result;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesBPlane::PutDirection ( enum AgECrdnDirectionType pRetVal ) {
    HRESULT _hr = put_Direction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAxesCustomScript wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesCustomScript::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesCustomScript::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesCustomScript::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesCustomScript::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesCustomScript::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesCustomScript::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesCustomScript::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesCustomScript::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesCustomScript::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesCustomScript::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesCustomScript::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesCustomScript::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesCustomScript::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesCustomScript::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesCustomScript::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesCustomScript::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesCustomScript::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesCustomScript::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesCustomScript::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesCustomScript::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesCustomScript::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesCustomScript::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesCustomScript::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_bstr_t _IAgCrdnAxesCustomScript::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesCustomScript::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAxesAttitudeFile wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesAttitudeFile::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesAttitudeFile::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAttitudeFile::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesAttitudeFile::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesAttitudeFile::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAttitudeFile::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAttitudeFile::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAttitudeFile::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesAttitudeFile::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesAttitudeFile::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesAttitudeFile::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesAttitudeFile::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesAttitudeFile::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesAttitudeFile::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesAttitudeFile::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesAttitudeFile::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesAttitudeFile::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesAttitudeFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAxesFixed wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesFixed::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesFixed::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesFixed::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesFixed::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesFixed::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesFixed::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFixed::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesFixed::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesFixed::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesFixed::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFixed::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesFixed::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesFixed::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesFixed::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesFixed::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesFixed::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesFixed::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesFixed::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesFixed::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesFixed::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesFixed::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesFixed::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesFixed::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

STKUtil::IAgOrientationPtr _IAgCrdnAxesFixed::GetFixedOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_FixedOrientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

//
// interface _IAgCrdnAxesModelAttach wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesModelAttach::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesModelAttach::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesModelAttach::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesModelAttach::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesModelAttach::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesModelAttach::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesModelAttach::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesModelAttach::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesModelAttach::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesModelAttach::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesModelAttach::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesModelAttach::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesModelAttach::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesModelAttach::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesModelAttach::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesModelAttach::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesModelAttach::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesModelAttach::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesModelAttach::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesModelAttach::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesModelAttach::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesModelAttach::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

_bstr_t _IAgCrdnAxesModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAxesSpinning wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesSpinning::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesSpinning::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesSpinning::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesSpinning::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesSpinning::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesSpinning::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesSpinning::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesSpinning::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesSpinning::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesSpinning::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesSpinning::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesSpinning::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesSpinning::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesSpinning::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesSpinning::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesSpinning::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesSpinning::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesSpinning::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesSpinning::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesSpinning::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesSpinning::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesSpinning::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAxesSpinning::GetSpinVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SpinVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesSpinning::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_variant_t _IAgCrdnAxesSpinning::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCrdnAxesSpinning::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnAxesSpinning::GetInitialOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_InitialOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesSpinning::PutInitialOffset ( double pRetVal ) {
    HRESULT _hr = put_InitialOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnAxesSpinning::GetSpinRate ( ) {
    double _result = 0;
    HRESULT _hr = get_SpinRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesSpinning::PutSpinRate ( double pRetVal ) {
    HRESULT _hr = put_SpinRate(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAxesOnSurface wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesOnSurface::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesOnSurface::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesOnSurface::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesOnSurface::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesOnSurface::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesOnSurface::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesOnSurface::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesOnSurface::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesOnSurface::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesOnSurface::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesOnSurface::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesOnSurface::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesOnSurface::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesOnSurface::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesOnSurface::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesOnSurface::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesOnSurface::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesOnSurface::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesOnSurface::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesOnSurface::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesOnSurface::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesOnSurface::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnAxesOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnAxesOnSurface::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesOnSurface::GetUseMSL ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMSL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesOnSurface::PutUseMSL ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMSL(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAxesTrajectory wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesTrajectory::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesTrajectory::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesTrajectory::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesTrajectory::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesTrajectory::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesTrajectory::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesTrajectory::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesTrajectory::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesTrajectory::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesTrajectory::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesTrajectory::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesTrajectory::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesTrajectory::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesTrajectory::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesTrajectory::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesTrajectory::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesTrajectory::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesTrajectory::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesTrajectory::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesTrajectory::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesTrajectory::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesTrajectory::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnAxesTrajectory::GetTrajectoryPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_TrajectoryPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnSystemRefToPtr _IAgCrdnAxesTrajectory::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

enum AgECrdnTrajectoryAxesType _IAgCrdnAxesTrajectory::GetTrajectoryAxesType ( ) {
    enum AgECrdnTrajectoryAxesType _result;
    HRESULT _hr = get_TrajectoryAxesType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesTrajectory::PutTrajectoryAxesType ( enum AgECrdnTrajectoryAxesType pRetVal ) {
    HRESULT _hr = put_TrajectoryAxesType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAxesLagrangeLibration wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesLagrangeLibration::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesLagrangeLibration::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesLagrangeLibration::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesLagrangeLibration::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesLagrangeLibration::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesLagrangeLibration::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesLagrangeLibration::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesLagrangeLibration::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesLagrangeLibration::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesLagrangeLibration::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesLagrangeLibration::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesLagrangeLibration::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesLagrangeLibration::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesLagrangeLibration::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesLagrangeLibration::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesLagrangeLibration::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputAxes, VectorInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesLagrangeLibration::TransformTo ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesLagrangeLibration::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * InputAxes, struct STKUtil::IAgCartesian3Vector * VectorInInputAxes, struct STKUtil::IAgCartesian3Vector * RateInInputAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputAxes, VectorInInputAxes, RateInInputAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesLagrangeLibration::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesLagrangeLibration::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesLagrangeLibration::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesLagrangeLibration::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnAxesLagrangeLibration::GetPrimaryCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_PrimaryCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnLagrangeLibrationPointType _IAgCrdnAxesLagrangeLibration::GetPointType ( ) {
    enum AgECrdnLagrangeLibrationPointType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesLagrangeLibration::PutPointType ( enum AgECrdnLagrangeLibrationPointType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCentralBodyCollectionPtr _IAgCrdnAxesLagrangeLibration::GetSecondaryCentralBodies ( ) {
    struct IAgCrdnCentralBodyCollection * _result = 0;
    HRESULT _hr = get_SecondaryCentralBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyCollectionPtr(_result, false);
}

//
// interface _IAgCrdnAngleBetweenVectors wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngleBetweenVectors::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngleBetweenVectors::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngleBetweenVectors::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngleBetweenVectors::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenVectors::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenVectors::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleBetweenVectors::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngleBetweenVectors::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngleBetweenVectors::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenVectors::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleBetweenVectors::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleBetweenVectors::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleBetweenVectors::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngleBetweenVectors::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngleBetweenVectors::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngleBetweenVectors::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngleBetweenVectors::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngleBetweenVectors::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngleBetweenVectors::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleBetweenVectors::GetFromVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_FromVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleBetweenVectors::GetToVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ToVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

//
// interface _IAgCrdnAngleBetweenPlanes wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngleBetweenPlanes::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngleBetweenPlanes::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngleBetweenPlanes::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngleBetweenPlanes::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenPlanes::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenPlanes::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleBetweenPlanes::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngleBetweenPlanes::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngleBetweenPlanes::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenPlanes::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleBetweenPlanes::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleBetweenPlanes::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleBetweenPlanes::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngleBetweenPlanes::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngleBetweenPlanes::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngleBetweenPlanes::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngleBetweenPlanes::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngleBetweenPlanes::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngleBetweenPlanes::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnAngleBetweenPlanes::GetFromPlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_FromPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnAngleBetweenPlanes::GetToPlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ToPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface _IAgCrdnAngleDihedral wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngleDihedral::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngleDihedral::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngleDihedral::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngleDihedral::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleDihedral::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleDihedral::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngleDihedral::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngleDihedral::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngleDihedral::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngleDihedral::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngleDihedral::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngleDihedral::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngleDihedral::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngleDihedral::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngleDihedral::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleDihedral::GetFromVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_FromVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleDihedral::GetToVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ToVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleDihedral::GetPoleAbout ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_PoleAbout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetCounterClockwiseRotation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CounterClockwiseRotation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAngleDihedral::PutCounterClockwiseRotation ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_CounterClockwiseRotation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetSignedAngle ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SignedAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAngleDihedral::PutSignedAngle ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_SignedAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAngleRotation wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngleRotation::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngleRotation::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngleRotation::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngleRotation::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleRotation::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleRotation::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleRotation::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngleRotation::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngleRotation::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngleRotation::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleRotation::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleRotation::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleRotation::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngleRotation::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngleRotation::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngleRotation::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngleRotation::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngleRotation::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngleRotation::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAngleRotation::GetFromAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_FromAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAngleRotation::GetToAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ToAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

enum AgECrdnDisplayAxisSelector _IAgCrdnAngleRotation::GetReferenceDirection ( ) {
    enum AgECrdnDisplayAxisSelector _result;
    HRESULT _hr = get_ReferenceDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAngleRotation::PutReferenceDirection ( enum AgECrdnDisplayAxisSelector pRetVal ) {
    HRESULT _hr = put_ReferenceDirection(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnAngleToPlane wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngleToPlane::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngleToPlane::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngleToPlane::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngleToPlane::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleToPlane::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleToPlane::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleToPlane::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngleToPlane::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngleToPlane::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngleToPlane::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleToPlane::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleToPlane::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleToPlane::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngleToPlane::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngleToPlane::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngleToPlane::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngleToPlane::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngleToPlane::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngleToPlane::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleToPlane::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnAngleToPlane::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

enum AgECrdnSignedAngleType _IAgCrdnAngleToPlane::GetSigned ( ) {
    enum AgECrdnSignedAngleType _result;
    HRESULT _hr = get_Signed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAngleToPlane::PutSigned ( enum AgECrdnSignedAngleType pRetVal ) {
    HRESULT _hr = put_Signed(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPlaneNormal wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPlaneNormal::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPlaneNormal::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneNormal::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlaneNormal::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneNormal::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneNormal::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneNormal::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPlaneNormal::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPlaneNormal::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPlaneNormal::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneNormal::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneNormal::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneNormal::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPlaneNormal::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPlaneType _IAgCrdnPlaneNormal::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr _IAgCrdnPlaneNormal::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr _IAgCrdnPlaneNormal::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr _IAgCrdnPlaneNormal::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr _IAgCrdnPlaneNormal::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr _IAgCrdnPlaneNormal::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnPlaneNormal::GetNormalVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_NormalVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnPlaneNormal::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPlaneNormal::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface _IAgCrdnPlaneQuadrant wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPlaneQuadrant::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPlaneQuadrant::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneQuadrant::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlaneQuadrant::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneQuadrant::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneQuadrant::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneQuadrant::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPlaneQuadrant::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPlaneQuadrant::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPlaneQuadrant::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneQuadrant::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneQuadrant::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneQuadrant::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPlaneQuadrant::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPlaneType _IAgCrdnPlaneQuadrant::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr _IAgCrdnPlaneQuadrant::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr _IAgCrdnPlaneQuadrant::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr _IAgCrdnPlaneQuadrant::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr _IAgCrdnPlaneQuadrant::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr _IAgCrdnPlaneQuadrant::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

IAgCrdnSystemRefToPtr _IAgCrdnPlaneQuadrant::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

enum AgECrdnQuadrantType _IAgCrdnPlaneQuadrant::GetQuadrant ( ) {
    enum AgECrdnQuadrantType _result;
    HRESULT _hr = get_Quadrant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPlaneQuadrant::PutQuadrant ( enum AgECrdnQuadrantType pRetVal ) {
    HRESULT _hr = put_Quadrant(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPlaneTrajectory wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPlaneTrajectory::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPlaneTrajectory::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneTrajectory::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlaneTrajectory::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneTrajectory::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneTrajectory::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneTrajectory::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPlaneTrajectory::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPlaneTrajectory::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPlaneTrajectory::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneTrajectory::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneTrajectory::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneTrajectory::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPlaneTrajectory::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPlaneType _IAgCrdnPlaneTrajectory::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr _IAgCrdnPlaneTrajectory::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr _IAgCrdnPlaneTrajectory::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr _IAgCrdnPlaneTrajectory::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr _IAgCrdnPlaneTrajectory::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr _IAgCrdnPlaneTrajectory::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPlaneTrajectory::GetPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Point(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnSystemRefToPtr _IAgCrdnPlaneTrajectory::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

double _IAgCrdnPlaneTrajectory::GetRotationOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPlaneTrajectory::PutRotationOffset ( double pRetVal ) {
    HRESULT _hr = put_RotationOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPlaneTriad wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPlaneTriad::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPlaneTriad::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneTriad::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlaneTriad::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneTriad::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneTriad::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneTriad::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPlaneTriad::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPlaneTriad::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPlaneTriad::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneTriad::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneTriad::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneTriad::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPlaneTriad::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPlaneType _IAgCrdnPlaneTriad::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr _IAgCrdnPlaneTriad::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr _IAgCrdnPlaneTriad::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr _IAgCrdnPlaneTriad::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr _IAgCrdnPlaneTriad::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr _IAgCrdnPlaneTriad::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPlaneTriad::GetPointA ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_PointA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPlaneTriad::GetPointB ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_PointB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPlaneTriad::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

double _IAgCrdnPlaneTriad::GetRotationOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPlaneTriad::PutRotationOffset ( double pRetVal ) {
    HRESULT _hr = put_RotationOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPointBPlane wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointBPlane::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointBPlane::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointBPlane::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointBPlane::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointBPlane::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointBPlane::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointBPlane::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointBPlane::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointBPlane::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointBPlane::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointBPlane::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointBPlane::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointBPlane::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointBPlane::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointBPlane::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointBPlane::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointBPlane::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnPointBPlane::GetTargetBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_TargetBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointBPlane::GetTrajectory ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Trajectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnPointBPlaneType _IAgCrdnPointBPlane::GetPointType ( ) {
    enum AgECrdnPointBPlaneType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointBPlane::PutPointType ( enum AgECrdnPointBPlaneType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnDirectionType _IAgCrdnPointBPlane::GetDirection ( ) {
    enum AgECrdnDirectionType _result;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointBPlane::PutDirection ( enum AgECrdnDirectionType pRetVal ) {
    HRESULT _hr = put_Direction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPointFile wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointFile::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointFile::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointFile::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointFile::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointFile::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointFile::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFile::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointFile::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointFile::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointFile::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFile::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointFile::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointFile::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointFile::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointFile::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointFile::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointFile::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

_bstr_t _IAgCrdnPointFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPointFixedInSystem wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointFixedInSystem::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointFixedInSystem::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointFixedInSystem::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointFixedInSystem::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointFixedInSystem::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointFixedInSystem::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFixedInSystem::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointFixedInSystem::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointFixedInSystem::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointFixedInSystem::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFixedInSystem::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointFixedInSystem::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointFixedInSystem::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointFixedInSystem::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointFixedInSystem::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointFixedInSystem::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointFixedInSystem::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnSystemRefToPtr _IAgCrdnPointFixedInSystem::GetReference ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_Reference(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

STKUtil::IAgPositionPtr _IAgCrdnPointFixedInSystem::GetFixedPoint ( ) {
    struct STKUtil::IAgPosition * _result = 0;
    HRESULT _hr = get_FixedPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgPositionPtr(_result, false);
}

//
// interface _IAgCrdnPointGrazing wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointGrazing::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointGrazing::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointGrazing::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointGrazing::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointGrazing::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointGrazing::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointGrazing::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointGrazing::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointGrazing::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointGrazing::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointGrazing::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointGrazing::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointGrazing::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointGrazing::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointGrazing::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointGrazing::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointGrazing::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnPointGrazing::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointGrazing::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnPointGrazing::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double _IAgCrdnPointGrazing::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointGrazing::PutAltitude ( double pRetVal ) {
    HRESULT _hr = put_Altitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPointGlint wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointGlint::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointGlint::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointGlint::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointGlint::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointGlint::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointGlint::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointGlint::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointGlint::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointGlint::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointGlint::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointGlint::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointGlint::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointGlint::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointGlint::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointGlint::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointGlint::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointGlint::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnPointGlint::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointGlint::GetSourcePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_SourcePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointGlint::GetObserverPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ObserverPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface _IAgCrdnPointCovarianceGrazing wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointCovarianceGrazing::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointCovarianceGrazing::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointCovarianceGrazing::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointCovarianceGrazing::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointCovarianceGrazing::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointCovarianceGrazing::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointCovarianceGrazing::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointCovarianceGrazing::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointCovarianceGrazing::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointCovarianceGrazing::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointCovarianceGrazing::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointCovarianceGrazing::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointCovarianceGrazing::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnPointCovarianceGrazing::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetTargetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TargetName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointCovarianceGrazing::PutTargetName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_TargetName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnPointCovarianceGrazing::GetDistance ( ) {
    double _result = 0;
    HRESULT _hr = get_Distance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCovarianceGrazing::PutDistance ( double pRetVal ) {
    HRESULT _hr = put_Distance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnPointCovarianceGrazing::GetProbability ( ) {
    double _result = 0;
    HRESULT _hr = get_Probability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCovarianceGrazing::PutProbability ( double pRetVal ) {
    HRESULT _hr = put_Probability(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnPointCovarianceGrazing::GetScale ( ) {
    double _result = 0;
    HRESULT _hr = get_Scale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCovarianceGrazing::PutScale ( double pRetVal ) {
    HRESULT _hr = put_Scale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnPointCovarianceGrazing::GetUseProbability ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseProbability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCovarianceGrazing::PutUseProbability ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseProbability(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPointPlaneIntersection wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointPlaneIntersection::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointPlaneIntersection::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointPlaneIntersection::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointPlaneIntersection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointPlaneIntersection::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointPlaneIntersection::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlaneIntersection::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointPlaneIntersection::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointPlaneIntersection::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointPlaneIntersection::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlaneIntersection::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointPlaneIntersection::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointPlaneIntersection::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointPlaneIntersection::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointPlaneIntersection::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointPlaneIntersection::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointPlaneIntersection::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnPointPlaneIntersection::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnPointPlaneIntersection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointPlaneIntersection::GetOriginPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_OriginPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface _IAgCrdnPointOnSurface wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointOnSurface::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointOnSurface::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointOnSurface::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointOnSurface::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointOnSurface::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointOnSurface::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointOnSurface::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointOnSurface::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointOnSurface::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointOnSurface::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointOnSurface::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointOnSurface::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointOnSurface::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointOnSurface::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointOnSurface::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointOnSurface::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointOnSurface::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnPointOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointOnSurface::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnReferenceShapeType _IAgCrdnPointOnSurface::GetReferenceShape ( ) {
    enum AgECrdnReferenceShapeType _result;
    HRESULT _hr = get_ReferenceShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointOnSurface::PutReferenceShape ( enum AgECrdnReferenceShapeType pRetVal ) {
    HRESULT _hr = put_ReferenceShape(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSurfaceType _IAgCrdnPointOnSurface::GetSurfaceType ( ) {
    enum AgECrdnSurfaceType _result;
    HRESULT _hr = get_SurfaceType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointOnSurface::PutSurfaceType ( enum AgECrdnSurfaceType pRetVal ) {
    HRESULT _hr = put_SurfaceType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPointModelAttach wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointModelAttach::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointModelAttach::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointModelAttach::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointModelAttach::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointModelAttach::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointModelAttach::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointModelAttach::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointModelAttach::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointModelAttach::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointModelAttach::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointModelAttach::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointModelAttach::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointModelAttach::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointModelAttach::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointModelAttach::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointModelAttach::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointModelAttach::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

_bstr_t _IAgCrdnPointModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnPointModelAttach::GetUseScale ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseScale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointModelAttach::PutUseScale ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseScale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPointPlaneProjection wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointPlaneProjection::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointPlaneProjection::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointPlaneProjection::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointPlaneProjection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointPlaneProjection::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointPlaneProjection::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlaneProjection::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointPlaneProjection::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointPlaneProjection::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointPlaneProjection::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlaneProjection::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointPlaneProjection::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointPlaneProjection::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointPlaneProjection::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointPlaneProjection::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointPlaneProjection::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointPlaneProjection::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointPlaneProjection::GetSourcePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_SourcePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnPointPlaneProjection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface _IAgCrdnPointLagrangeLibration wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointLagrangeLibration::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointLagrangeLibration::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointLagrangeLibration::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointLagrangeLibration::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointLagrangeLibration::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointLagrangeLibration::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointLagrangeLibration::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointLagrangeLibration::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointLagrangeLibration::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointLagrangeLibration::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointLagrangeLibration::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointLagrangeLibration::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointLagrangeLibration::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointLagrangeLibration::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointLagrangeLibration::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointLagrangeLibration::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointLagrangeLibration::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnPointLagrangeLibration::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnLagrangeLibrationPointType _IAgCrdnPointLagrangeLibration::GetPointType ( ) {
    enum AgECrdnLagrangeLibrationPointType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointLagrangeLibration::PutPointType ( enum AgECrdnLagrangeLibrationPointType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCentralBodyCollectionPtr _IAgCrdnPointLagrangeLibration::GetSecondaryCentralBodies ( ) {
    struct IAgCrdnCentralBodyCollection * _result = 0;
    HRESULT _hr = get_SecondaryCentralBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyCollectionPtr(_result, false);
}

//
// interface _IAgCrdnSystemAssembled wrapper method implementations
//

enum AgECrdnKind _IAgCrdnSystemAssembled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnSystemAssembled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnSystemAssembled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnSystemAssembled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystemAssembled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystemAssembled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemAssembled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnSystemAssembled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnSystemAssembled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnSystemAssembled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemAssembled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystemAssembled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystemAssembled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnSystemAssembled::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnSystemType _IAgCrdnSystemAssembled::GetType ( ) {
    enum AgECrdnSystemType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnSystemTransformResultPtr _IAgCrdnSystemAssembled::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnSystem * InputSystem, struct STKUtil::IAgCartesian3Vector * PositionInInputSystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputSystem, PositionInInputSystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr _IAgCrdnSystemAssembled::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * InputSystem, struct STKUtil::IAgCartesian3Vector * PositionInInputSystem, struct STKUtil::IAgCartesian3Vector * VelocityInInputSystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputSystem, PositionInInputSystem, VelocityInInputSystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

IAgCrdnSystemTransformResultPtr _IAgCrdnSystemAssembled::TransformTo ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputSystem, PositionInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr _IAgCrdnSystemAssembled::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem, struct STKUtil::IAgCartesian3Vector * VelocityInMySystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputSystem, PositionInMySystem, VelocityInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

IAgCrdnSystemFindInSystemResultPtr _IAgCrdnSystemAssembled::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnSystemFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemFindInSystemResultPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnSystemAssembled::GetOriginPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_OriginPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnSystemAssembled::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

//
// interface _IAgCrdnSystemOnSurface wrapper method implementations
//

enum AgECrdnKind _IAgCrdnSystemOnSurface::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnSystemOnSurface::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnSystemOnSurface::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnSystemOnSurface::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystemOnSurface::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystemOnSurface::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemOnSurface::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnSystemOnSurface::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnSystemOnSurface::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnSystemOnSurface::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemOnSurface::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystemOnSurface::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystemOnSurface::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnSystemOnSurface::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnSystemType _IAgCrdnSystemOnSurface::GetType ( ) {
    enum AgECrdnSystemType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnSystemTransformResultPtr _IAgCrdnSystemOnSurface::TransformFrom ( const _variant_t & Epoch, struct IAgCrdnSystem * InputSystem, struct STKUtil::IAgCartesian3Vector * PositionInInputSystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_TransformFrom(Epoch, InputSystem, PositionInInputSystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr _IAgCrdnSystemOnSurface::TransformFromWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * InputSystem, struct STKUtil::IAgCartesian3Vector * PositionInInputSystem, struct STKUtil::IAgCartesian3Vector * VelocityInInputSystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformFromWithRate(Epoch, InputSystem, PositionInInputSystem, VelocityInInputSystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

IAgCrdnSystemTransformResultPtr _IAgCrdnSystemOnSurface::TransformTo ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_TransformTo(Epoch, OutputSystem, PositionInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr _IAgCrdnSystemOnSurface::TransformToWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem, struct STKUtil::IAgCartesian3Vector * VelocityInMySystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformToWithRate(Epoch, OutputSystem, PositionInMySystem, VelocityInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

IAgCrdnSystemFindInSystemResultPtr _IAgCrdnSystemOnSurface::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnSystemFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemFindInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnSystemOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

double _IAgCrdnSystemOnSurface::GetAzimuthAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_AzimuthAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSystemOnSurface::PutAzimuthAngle ( double pRetVal ) {
    HRESULT _hr = put_AzimuthAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnSystemOnSurface::GetUseMSL ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMSL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSystemOnSurface::PutUseMSL ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMSL(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnLLAPositionPtr _IAgCrdnSystemOnSurface::GetPosition ( ) {
    struct IAgCrdnLLAPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnLLAPositionPtr(_result, false);
}

//
// interface _IAgCrdnLLAPosition wrapper method implementations
//

double _IAgCrdnLLAPosition::GetLatitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Latitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLLAPosition::PutLatitude ( double pRetVal ) {
    HRESULT _hr = put_Latitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnLLAPosition::GetLongitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Longitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLLAPosition::PutLongitude ( double pRetVal ) {
    HRESULT _hr = put_Longitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnLLAPosition::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLLAPosition::PutAltitude ( double pRetVal ) {
    HRESULT _hr = put_Altitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorAngleRate wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorAngleRate::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorAngleRate::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorAngleRate::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorAngleRate::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorAngleRate::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorAngleRate::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorAngleRate::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorAngleRate::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorAngleRate::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorAngleRate::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorAngleRate::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorAngleRate::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorAngleRate::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorAngleRate::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorAngleRate::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorAngleRate::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorAngleRate::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAngleRefToPtr _IAgCrdnVectorAngleRate::GetAngle ( ) {
    struct IAgCrdnAngleRefTo * _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleRefToPtr(_result, false);
}

//
// interface _IAgCrdnVectorApoapsis wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorApoapsis::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorApoapsis::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorApoapsis::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorApoapsis::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorApoapsis::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorApoapsis::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorApoapsis::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorApoapsis::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorApoapsis::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorApoapsis::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorApoapsis::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorApoapsis::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorApoapsis::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorApoapsis::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorApoapsis::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorApoapsis::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorApoapsis::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorApoapsis::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorApoapsis::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory _IAgCrdnVectorApoapsis::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorApoapsis::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorFixedAtEpoch wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorFixedAtEpoch::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorFixedAtEpoch::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorFixedAtEpoch::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorFixedAtEpoch::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorFixedAtEpoch::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorFixedAtEpoch::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedAtEpoch::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorFixedAtEpoch::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorFixedAtEpoch::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorFixedAtEpoch::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedAtEpoch::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorFixedAtEpoch::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorFixedAtEpoch::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorFixedAtEpoch::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorFixedAtEpoch::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorFixedAtEpoch::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorFixedAtEpoch::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

_variant_t _IAgCrdnVectorFixedAtEpoch::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCrdnVectorFixedAtEpoch::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorFixedAtEpoch::GetSourceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SourceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorFixedAtEpoch::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

//
// interface _IAgCrdnVectorAngularVelocity wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorAngularVelocity::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorAngularVelocity::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorAngularVelocity::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorAngularVelocity::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorAngularVelocity::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorAngularVelocity::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorAngularVelocity::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorAngularVelocity::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorAngularVelocity::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorAngularVelocity::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorAngularVelocity::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorAngularVelocity::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorAngularVelocity::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorAngularVelocity::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorAngularVelocity::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorAngularVelocity::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorAngularVelocity::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorAngularVelocity::GetAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_Axes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorAngularVelocity::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

//
// interface _IAgCrdnVectorConing wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorConing::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorConing::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorConing::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorConing::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorConing::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorConing::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorConing::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorConing::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorConing::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorConing::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorConing::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorConing::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorConing::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorConing::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorConing::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorConing::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorConing::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorConing::GetAboutVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_AboutVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorConing::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double _IAgCrdnVectorConing::GetStartClockAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_StartClockAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorConing::PutStartClockAngle ( double pRetVal ) {
    HRESULT _hr = put_StartClockAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorConing::GetStopClockAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_StopClockAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorConing::PutStopClockAngle ( double pRetVal ) {
    HRESULT _hr = put_StopClockAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgCrdnVectorConing::GetStartEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_StartEpoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCrdnVectorConing::PutStartEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_StartEpoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorConing::GetClockAngleRate ( ) {
    double _result = 0;
    HRESULT _hr = get_ClockAngleRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorConing::PutClockAngleRate ( double pRetVal ) {
    HRESULT _hr = put_ClockAngleRate(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSweepMode _IAgCrdnVectorConing::GetMode ( ) {
    enum AgECrdnSweepMode _result;
    HRESULT _hr = get_Mode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorConing::PutMode ( enum AgECrdnSweepMode pRetVal ) {
    HRESULT _hr = put_Mode(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorCross wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorCross::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorCross::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorCross::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorCross::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorCross::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorCross::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorCross::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorCross::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorCross::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorCross::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorCross::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorCross::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorCross::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorCross::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorCross::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorCross::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorCross::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorCross::GetFrom ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_From(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorCross::GetTo ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_To(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

//
// interface _IAgCrdnVectorCustomScript wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorCustomScript::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorCustomScript::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorCustomScript::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorCustomScript::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorCustomScript::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorCustomScript::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorCustomScript::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorCustomScript::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorCustomScript::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorCustomScript::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorCustomScript::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorCustomScript::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorCustomScript::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorCustomScript::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorCustomScript::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorCustomScript::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorCustomScript::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorCustomScript::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_bstr_t _IAgCrdnVectorCustomScript::GetScriptFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ScriptFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorCustomScript::PutScriptFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ScriptFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorCustomScript::GetInitializationScriptFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_InitializationScriptFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorCustomScript::PutInitializationScriptFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_InitializationScriptFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorDerivative wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorDerivative::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorDerivative::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorDerivative::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorDerivative::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDerivative::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDerivative::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDerivative::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorDerivative::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorDerivative::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorDerivative::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDerivative::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDerivative::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDerivative::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorDerivative::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorDerivative::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorDerivative::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorDerivative::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorDerivative::GetVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorDerivative::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

//
// interface _IAgCrdnVectorDisplacement wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorDisplacement::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorDisplacement::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorDisplacement::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorDisplacement::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDisplacement::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDisplacement::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorDisplacement::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorDisplacement::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorDisplacement::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorDisplacement::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorDisplacement::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorDisplacement::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorDisplacement::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorDisplacement::GetOrigin ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Origin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorDisplacement::GetDestination ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Destination(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetApparent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Apparent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorDisplacement::PutApparent ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_Apparent(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetIgnoreAbberation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IgnoreAbberation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorDisplacement::PutIgnoreAbberation ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IgnoreAbberation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense _IAgCrdnVectorDisplacement::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorDisplacement::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemRefToPtr _IAgCrdnVectorDisplacement::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

//
// interface _IAgCrdnVectorTwoPlanesIntersection wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorTwoPlanesIntersection::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorTwoPlanesIntersection::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorTwoPlanesIntersection::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorTwoPlanesIntersection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorTwoPlanesIntersection::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorTwoPlanesIntersection::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorTwoPlanesIntersection::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorTwoPlanesIntersection::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorTwoPlanesIntersection::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorTwoPlanesIntersection::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorTwoPlanesIntersection::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorTwoPlanesIntersection::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorTwoPlanesIntersection::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorTwoPlanesIntersection::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorTwoPlanesIntersection::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorTwoPlanesIntersection::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorTwoPlanesIntersection::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnVectorTwoPlanesIntersection::GetPlaneA ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_PlaneA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnVectorTwoPlanesIntersection::GetPlaneB ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_PlaneB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface _IAgCrdnVectorModelAttach wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorModelAttach::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorModelAttach::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorModelAttach::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorModelAttach::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorModelAttach::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorModelAttach::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorModelAttach::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorModelAttach::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorModelAttach::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorModelAttach::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorModelAttach::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorModelAttach::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorModelAttach::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorModelAttach::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorModelAttach::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorModelAttach::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorModelAttach::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

_bstr_t _IAgCrdnVectorModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorProjection wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorProjection::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorProjection::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorProjection::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorProjection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorProjection::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorProjection::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorProjection::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorProjection::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorProjection::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorProjection::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorProjection::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorProjection::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorProjection::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorProjection::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorProjection::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorProjection::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorProjection::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorProjection::GetSource ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_Source(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnVectorProjection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface _IAgCrdnVectorScaled wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorScaled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorScaled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorScaled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorScaled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorScaled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorScaled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorScaled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorScaled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorScaled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorScaled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorScaled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorScaled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorScaled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorScaled::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorScaled::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorScaled::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorScaled::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorScaled::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double _IAgCrdnVectorScaled::GetScale ( ) {
    double _result = 0;
    HRESULT _hr = get_Scale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScaled::PutScale ( double pRetVal ) {
    HRESULT _hr = put_Scale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVectorScaled::GetIsNormalized ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNormalized(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScaled::PutIsNormalized ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IsNormalized(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorEccentricity wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorEccentricity::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorEccentricity::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorEccentricity::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorEccentricity::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorEccentricity::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorEccentricity::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorEccentricity::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorEccentricity::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorEccentricity::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorEccentricity::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorEccentricity::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorEccentricity::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorEccentricity::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorEccentricity::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorEccentricity::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorEccentricity::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorEccentricity::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorEccentricity::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorEccentricity::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory _IAgCrdnVectorEccentricity::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorEccentricity::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorFixedInAxes wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorFixedInAxes::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorFixedInAxes::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorFixedInAxes::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorFixedInAxes::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorFixedInAxes::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorFixedInAxes::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedInAxes::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorFixedInAxes::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorFixedInAxes::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorFixedInAxes::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedInAxes::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorFixedInAxes::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorFixedInAxes::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorFixedInAxes::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorFixedInAxes::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorFixedInAxes::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorFixedInAxes::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorFixedInAxes::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

STKUtil::IAgPositionPtr _IAgCrdnVectorFixedInAxes::GetPosition ( ) {
    struct STKUtil::IAgPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgPositionPtr(_result, false);
}

//
// interface _IAgCrdnVectorLineOfNodes wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorLineOfNodes::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorLineOfNodes::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorLineOfNodes::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorLineOfNodes::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorLineOfNodes::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorLineOfNodes::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorLineOfNodes::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorLineOfNodes::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorLineOfNodes::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorLineOfNodes::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorLineOfNodes::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorLineOfNodes::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorLineOfNodes::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorLineOfNodes::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorLineOfNodes::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorLineOfNodes::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorLineOfNodes::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorLineOfNodes::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorLineOfNodes::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface _IAgCrdnVectorOrbitAngularMomentum wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorOrbitAngularMomentum::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorOrbitAngularMomentum::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorOrbitAngularMomentum::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorOrbitAngularMomentum::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitAngularMomentum::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitAngularMomentum::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorOrbitAngularMomentum::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorOrbitAngularMomentum::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorOrbitAngularMomentum::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitAngularMomentum::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorOrbitAngularMomentum::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorOrbitAngularMomentum::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorOrbitAngularMomentum::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorOrbitAngularMomentum::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorOrbitAngularMomentum::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorOrbitAngularMomentum::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorOrbitAngularMomentum::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorOrbitAngularMomentum::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorOrbitAngularMomentum::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory _IAgCrdnVectorOrbitAngularMomentum::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorOrbitAngularMomentum::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorOrbitNormal wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorOrbitNormal::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorOrbitNormal::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorOrbitNormal::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorOrbitNormal::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitNormal::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitNormal::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorOrbitNormal::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorOrbitNormal::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorOrbitNormal::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitNormal::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorOrbitNormal::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorOrbitNormal::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorOrbitNormal::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorOrbitNormal::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorOrbitNormal::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorOrbitNormal::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorOrbitNormal::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorOrbitNormal::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorOrbitNormal::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory _IAgCrdnVectorOrbitNormal::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorOrbitNormal::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorPeriapsis wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorPeriapsis::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorPeriapsis::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorPeriapsis::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorPeriapsis::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorPeriapsis::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorPeriapsis::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorPeriapsis::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorPeriapsis::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorPeriapsis::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorPeriapsis::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorPeriapsis::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorPeriapsis::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorPeriapsis::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorPeriapsis::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorPeriapsis::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorPeriapsis::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorPeriapsis::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorPeriapsis::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorPeriapsis::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory _IAgCrdnVectorPeriapsis::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorPeriapsis::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorReflection wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorReflection::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorReflection::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorReflection::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorReflection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorReflection::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorReflection::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorReflection::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorReflection::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorReflection::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorReflection::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorReflection::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorReflection::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorReflection::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorReflection::GetIncomingVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_IncomingVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetUseOppositeOfSelectedVector ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseOppositeOfSelectedVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorReflection::PutUseOppositeOfSelectedVector ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseOppositeOfSelectedVector(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorReflection::GetNormalVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_NormalVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetAllowReflectionsOnBackside ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowReflectionsOnBackside(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorReflection::PutAllowReflectionsOnBackside ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_AllowReflectionsOnBackside(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorReflection::GetScaleFactor ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorReflection::PutScaleFactor ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactor(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorDirectionToStar wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorDirectionToStar::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorDirectionToStar::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDirectionToStar::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorDirectionToStar::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorDirectionToStar::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDirectionToStar::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDirectionToStar::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDirectionToStar::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorDirectionToStar::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorDirectionToStar::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorDirectionToStar::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorDirectionToStar::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetSelectedStar ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SelectedStar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorDirectionToStar::PutSelectedStar ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SelectedStar(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorFactory wrapper method implementations
//

IAgCrdnVectorPtr _IAgCrdnVectorFactory::Create ( _bstr_t VectorName, _bstr_t Description, enum AgECrdnVectorType VectorType ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = raw_Create(VectorName, Description, VectorType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFactory::IsTypeSupported ( enum AgECrdnVectorType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorDisplacementPtr _IAgCrdnVectorFactory::CreateDisplacementVector ( _bstr_t VectorName, struct IAgCrdnPoint * OriginPoint, struct IAgCrdnPoint * DestPoint ) {
    struct IAgCrdnVectorDisplacement * _result = 0;
    HRESULT _hr = raw_CreateDisplacementVector(VectorName, OriginPoint, DestPoint, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorDisplacementPtr(_result, false);
}

IAgCrdnVectorCrossPtr _IAgCrdnVectorFactory::CreateCrossVector ( _bstr_t VectorName, struct IAgCrdnVector * VectorTo, struct IAgCrdnVector * VectorFrom ) {
    struct IAgCrdnVectorCross * _result = 0;
    HRESULT _hr = raw_CreateCrossVector(VectorName, VectorTo, VectorFrom, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorCrossPtr(_result, false);
}

//
// interface _IAgCrdnAxesFactory wrapper method implementations
//

IAgCrdnAxesPtr _IAgCrdnAxesFactory::Create ( _bstr_t AxesName, _bstr_t Description, enum AgECrdnAxesType AxesType ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = raw_Create(AxesName, Description, AxesType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFactory::IsTypeSupported ( enum AgECrdnAxesType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnSystemFactory wrapper method implementations
//

IAgCrdnSystemPtr _IAgCrdnSystemFactory::Create ( _bstr_t SystemName, _bstr_t Description, enum AgECrdnSystemType SystemType ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = raw_Create(SystemName, Description, SystemType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemFactory::IsTypeSupported ( enum AgECrdnSystemType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnPointFactory wrapper method implementations
//

IAgCrdnPointPtr _IAgCrdnPointFactory::Create ( _bstr_t PointName, _bstr_t Description, enum AgECrdnPointType PointType ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_Create(PointName, Description, PointType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFactory::IsTypeSupported ( enum AgECrdnPointType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnPlaneFactory wrapper method implementations
//

IAgCrdnPlanePtr _IAgCrdnPlaneFactory::Create ( _bstr_t PlaneName, _bstr_t Description, enum AgECrdnPlaneType PlaneType ) {
    struct IAgCrdnPlane * _result = 0;
    HRESULT _hr = raw_Create(PlaneName, Description, PlaneType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlanePtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneFactory::IsTypeSupported ( enum AgECrdnPlaneType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnAngleFactory wrapper method implementations
//

IAgCrdnAnglePtr _IAgCrdnAngleFactory::Create ( _bstr_t AngleName, _bstr_t Description, enum AgECrdnAngleType AngleType ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = raw_Create(AngleName, Description, AngleType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleFactory::IsTypeSupported ( enum AgECrdnAngleType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnProvider wrapper method implementations
//

IAgCrdnVectorGroupPtr _IAgCrdnProvider::GetVectors ( ) {
    struct IAgCrdnVectorGroup * _result = 0;
    HRESULT _hr = get_Vectors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorGroupPtr(_result, false);
}

IAgCrdnPointGroupPtr _IAgCrdnProvider::GetPoints ( ) {
    struct IAgCrdnPointGroup * _result = 0;
    HRESULT _hr = get_Points(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointGroupPtr(_result, false);
}

IAgCrdnAngleGroupPtr _IAgCrdnProvider::GetAngles ( ) {
    struct IAgCrdnAngleGroup * _result = 0;
    HRESULT _hr = get_Angles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleGroupPtr(_result, false);
}

IAgCrdnAxesGroupPtr _IAgCrdnProvider::GetAxes ( ) {
    struct IAgCrdnAxesGroup * _result = 0;
    HRESULT _hr = get_Axes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesGroupPtr(_result, false);
}

IAgCrdnPlaneGroupPtr _IAgCrdnProvider::GetPlanes ( ) {
    struct IAgCrdnPlaneGroup * _result = 0;
    HRESULT _hr = get_Planes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneGroupPtr(_result, false);
}

IAgCrdnSystemGroupPtr _IAgCrdnProvider::GetSystems ( ) {
    struct IAgCrdnSystemGroup * _result = 0;
    HRESULT _hr = get_Systems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemGroupPtr(_result, false);
}

IAgCrdnWellKnownSystemsPtr _IAgCrdnProvider::GetWellKnownSystems ( ) {
    struct IAgCrdnWellKnownSystems * _result = 0;
    HRESULT _hr = get_WellKnownSystems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSystemsPtr(_result, false);
}

IAgCrdnWellKnownAxesPtr _IAgCrdnProvider::GetWellKnownAxes ( ) {
    struct IAgCrdnWellKnownAxes * _result = 0;
    HRESULT _hr = get_WellKnownAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownAxesPtr(_result, false);
}

//
// interface _IAgCrdnRootSettings wrapper method implementations
//

VARIANT_BOOL _IAgCrdnRootSettings::GetForce3DNotify ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Force3DNotify(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnRootSettings::PutForce3DNotify ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_Force3DNotify(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnRoot wrapper method implementations
//

IAgCrdnProviderPtr _IAgCrdnRoot::GetTemplateProvider ( _bstr_t ClassName ) {
    struct IAgCrdnProvider * _result = 0;
    HRESULT _hr = raw_GetTemplateProvider(ClassName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnProviderPtr(_result, false);
}

IAgCrdnProviderPtr _IAgCrdnRoot::GetProvider ( _bstr_t InstPath ) {
    struct IAgCrdnProvider * _result = 0;
    HRESULT _hr = raw_GetProvider(InstPath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnProviderPtr(_result, false);
}

IAgCrdnWellKnownSystemsPtr _IAgCrdnRoot::GetWellKnownSystems ( ) {
    struct IAgCrdnWellKnownSystems * _result = 0;
    HRESULT _hr = get_WellKnownSystems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSystemsPtr(_result, false);
}

IAgCrdnWellKnownAxesPtr _IAgCrdnRoot::GetWellKnownAxes ( ) {
    struct IAgCrdnWellKnownAxes * _result = 0;
    HRESULT _hr = get_WellKnownAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownAxesPtr(_result, false);
}

IAgCrdnRootSettingsPtr _IAgCrdnRoot::GetSettings ( ) {
    struct IAgCrdnRootSettings * _result = 0;
    HRESULT _hr = get_Settings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnRootSettingsPtr(_result, false);
}

//
// interface _IAgCrdnWellKnownEarthSystems wrapper method implementations
//

IAgCrdnSystemPtr _IAgCrdnWellKnownEarthSystems::GetFixed ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownEarthSystems::GetICRF ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownEarthSystems::GetInertial ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

//
// interface _IAgCrdnWellKnownEarthAxes wrapper method implementations
//

IAgCrdnAxesPtr _IAgCrdnWellKnownEarthAxes::GetFixed ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownEarthAxes::GetICRF ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownEarthAxes::GetInertial ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownEarthAxes::GetJ2000 ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface _IAgCrdnWellKnownSunSystems wrapper method implementations
//

IAgCrdnSystemPtr _IAgCrdnWellKnownSunSystems::GetFixed ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownSunSystems::GetICRF ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownSunSystems::GetInertial ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownSunSystems::GetJ2000 ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownSunSystems::GetBarycenter ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Barycenter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

//
// interface _IAgCrdnWellKnownSunAxes wrapper method implementations
//

IAgCrdnAxesPtr _IAgCrdnWellKnownSunAxes::GetFixed ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownSunAxes::GetICRF ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownSunAxes::GetInertial ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownSunAxes::GetJ2000 ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface _IAgCrdnWellKnownSystems wrapper method implementations
//

IAgCrdnWellKnownEarthSystemsPtr _IAgCrdnWellKnownSystems::GetEarth ( ) {
    struct IAgCrdnWellKnownEarthSystems * _result = 0;
    HRESULT _hr = get_Earth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownEarthSystemsPtr(_result, false);
}

IAgCrdnWellKnownSunSystemsPtr _IAgCrdnWellKnownSystems::GetSun ( ) {
    struct IAgCrdnWellKnownSunSystems * _result = 0;
    HRESULT _hr = get_Sun(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSunSystemsPtr(_result, false);
}

//
// interface _IAgCrdnWellKnownAxes wrapper method implementations
//

IAgCrdnWellKnownEarthAxesPtr _IAgCrdnWellKnownAxes::GetEarth ( ) {
    struct IAgCrdnWellKnownEarthAxes * _result = 0;
    HRESULT _hr = get_Earth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownEarthAxesPtr(_result, false);
}

IAgCrdnWellKnownSunAxesPtr _IAgCrdnWellKnownAxes::GetSun ( ) {
    struct IAgCrdnWellKnownSunAxes * _result = 0;
    HRESULT _hr = get_Sun(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSunAxesPtr(_result, false);
}

//
// interface _IAgCrdnMethodCallResult wrapper method implementations
//

double _IAgCrdnMethodCallResult::GetAngleRate ( ) {
    double _result = 0;
    HRESULT _hr = get_AngleRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgCrdnMethodCallResult::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetVectorFrom ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorFrom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetVectorTo ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorTo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetVectorAbout ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorAbout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetOriginPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_OriginPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetOriginVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_OriginVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetXAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetXAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetYAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetYAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgOrientationPtr _IAgCrdnMethodCallResult::GetOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnMethodCallResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnInterval wrapper method implementations
//

_variant_t _IAgCrdnInterval::GetStart ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t _IAgCrdnInterval::GetStop ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Stop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _IAgCrdnCentralBody wrapper method implementations
//

_bstr_t _IAgCrdnCentralBody::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface _IAgCrdnCentralBodyRefTo wrapper method implementations
//

_bstr_t _IAgCrdnCentralBodyRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCentralBodyRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnCentralBodyRefTo::SetCentralBody ( struct IAgCrdnCentralBody * CentralBody ) {
    HRESULT _hr = raw_SetCentralBody(CentralBody);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnCentralBodyPtr _IAgCrdnCentralBodyRefTo::GetCentralBody ( ) {
    struct IAgCrdnCentralBody * _result = 0;
    HRESULT _hr = raw_GetCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyPtr(_result, false);
}

} // namespace AgSTKVgtLib
