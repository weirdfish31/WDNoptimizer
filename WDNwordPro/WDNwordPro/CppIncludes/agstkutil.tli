// Created by Microsoft (R) C/C++ Compiler Version 15.00.30729.01 (cc6e11a1).
//
// c:\r_stk_v9.2.x\source\lib\release.net\tlhbuilder\agstkutil.tli
//
// Wrapper implementations for Win32 type library AgStkUtil.tlb
// compiler-generated file created 11/23/11 at 05:29:07 - DO NOT EDIT!

#pragma once

namespace STKUtil {

//
// interface IAgExecCmdResult wrapper method implementations
//

long IAgExecCmdResult::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgExecCmdResult::GetItem ( long Index ) {
    BSTR _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IUnknownPtr IAgExecCmdResult::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

SAFEARRAY * IAgExecCmdResult::Range ( long StartIndex, long StopIndex ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_Range(StartIndex, StopIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IAgExecCmdResult::GetIsSucceeded ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSucceeded(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgExecMultiCmdResult wrapper method implementations
//

long IAgExecMultiCmdResult::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgExecCmdResultPtr IAgExecMultiCmdResult::GetItem ( long Index ) {
    struct IAgExecCmdResult * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgExecCmdResultPtr(_result, false);
}

IUnknownPtr IAgExecMultiCmdResult::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgQuantity wrapper method implementations
//

_bstr_t IAgQuantity::GetDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgQuantity::GetUnit ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Unit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT IAgQuantity::ConvertToUnit ( _bstr_t UnitAbbrv ) {
    HRESULT _hr = raw_ConvertToUnit(UnitAbbrv);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

double IAgQuantity::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgQuantity::PutValue ( double pValue ) {
    HRESULT _hr = put_Value(pValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgQuantityPtr IAgQuantity::Add ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Add(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr IAgQuantity::Subtract ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Subtract(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr IAgQuantity::MultiplyQty ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_MultiplyQty(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr IAgQuantity::DivideQty ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_DivideQty(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

//
// interface IAgDate wrapper method implementations
//

_bstr_t IAgDate::Format ( _bstr_t Unit ) {
    BSTR _result = 0;
    HRESULT _hr = raw_Format(Unit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT IAgDate::SetDate ( _bstr_t Unit, _bstr_t Value ) {
    HRESULT _hr = raw_SetDate(Unit, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

DATE IAgDate::GetOLEDate ( ) {
    DATE _result = 0;
    HRESULT _hr = get_OLEDate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDate::PutOLEDate ( DATE pDate ) {
    HRESULT _hr = put_OLEDate(pDate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IAgDate::GetWholeDays ( ) {
    long _result = 0;
    HRESULT _hr = get_WholeDays(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDate::PutWholeDays ( long pVal ) {
    HRESULT _hr = put_WholeDays(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgDate::GetSecIntoDay ( ) {
    double _result = 0;
    HRESULT _hr = get_SecIntoDay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDate::PutSecIntoDay ( double pVal ) {
    HRESULT _hr = put_SecIntoDay(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IAgDate::GetWholeDaysUTC ( ) {
    long _result = 0;
    HRESULT _hr = get_WholeDaysUTC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDate::PutWholeDaysUTC ( long pVal ) {
    HRESULT _hr = put_WholeDaysUTC(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgDate::GetSecIntoDayUTC ( ) {
    double _result = 0;
    HRESULT _hr = get_SecIntoDayUTC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDate::PutSecIntoDayUTC ( double pVal ) {
    HRESULT _hr = put_SecIntoDayUTC(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgDatePtr IAgDate::Add ( _bstr_t Unit, double Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_Add(Unit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgDatePtr IAgDate::Subtract ( _bstr_t Unit, double Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_Subtract(Unit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgQuantityPtr IAgDate::Span ( struct IAgDate * Date ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Span(Date, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

//
// interface IAgPosition wrapper method implementations
//

IAgPositionPtr IAgPosition::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType IAgPosition::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgPosition::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IAgPosition::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * IAgPosition::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgPosition::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgPosition::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgPosition::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgPosition::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgDirection wrapper method implementations
//

IAgDirectionPtr IAgDirection::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType IAgDirection::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgDirection::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgDirection::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgDirection::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgDirection::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgDirection::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgOrientation wrapper method implementations
//

IAgOrientationPtr IAgOrientation::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType IAgOrientation::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgOrientation::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgOrientation::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgOrientation::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgOrientation::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgOrientation::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgOrbitState wrapper method implementations
//

IAgOrbitStatePtr IAgOrbitState::ConvertTo ( enum AgEOrbitStateType Type ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

enum AgEOrbitStateType IAgOrbitState::GetOrbitStateType ( ) {
    enum AgEOrbitStateType _result;
    HRESULT _hr = get_OrbitStateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgOrbitState::Assign ( struct IAgOrbitState * pOrbitState ) {
    HRESULT _hr = raw_Assign(pOrbitState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignClassical ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double Eccentricity, double Inclination, double ArgOfPerigee, double RAAN, double MeanAnomaly ) {
    HRESULT _hr = raw_AssignClassical(ECoordinateSystem, SemiMajorAxis, Eccentricity, Inclination, ArgOfPerigee, RAAN, MeanAnomaly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignCartesian ( enum AgECoordinateSystem ECoordinateSystem, double XPosition, double YPosition, double ZPosition, double XVelocity, double YVelocity, double ZVelocity ) {
    HRESULT _hr = raw_AssignCartesian(ECoordinateSystem, XPosition, YPosition, ZPosition, XVelocity, YVelocity, ZVelocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignGeodetic ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double LatitudeRate, double LongitudeRate, double AltitudeRate ) {
    HRESULT _hr = raw_AssignGeodetic(ECoordinateSystem, Latitude, Longitude, Altitude, LatitudeRate, LongitudeRate, AltitudeRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignEquinoctial ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon, enum AgEEquinoctialFormulation EquinoctialFormulation ) {
    HRESULT _hr = raw_AssignEquinoctial(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon, EquinoctialFormulation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignMixedSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignMixedSpherical(ECoordinateSystem, Latitude, Longitude, Altitude, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Radius, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignSpherical(ECoordinateSystem, Latitude, Longitude, Radius, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IAgOrbitState::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t IAgOrbitState::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrbitState::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCartesian3Vector wrapper method implementations
//

double IAgCartesian3Vector::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian3Vector::PutX ( double pRetVal ) {
    HRESULT _hr = put_X(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCartesian3Vector::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian3Vector::PutY ( double pRetVal ) {
    HRESULT _hr = put_Y(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCartesian3Vector::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian3Vector::PutZ ( double pRetVal ) {
    HRESULT _hr = put_Z(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCartesian3Vector::Get ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_Get(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCartesian3Vector::Set ( double X, double Y, double Z ) {
    HRESULT _hr = raw_Set(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgCartesian3Vector::ToArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ToArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgConversionUtility wrapper method implementations
//

double _IAgConversionUtility::ConvertQuantity ( _bstr_t DimensionName, _bstr_t FromUnit, _bstr_t ToUnit, double Value ) {
    double _result = 0;
    HRESULT _hr = raw_ConvertQuantity(DimensionName, FromUnit, ToUnit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgConversionUtility::ConvertDate ( _bstr_t FromUnit, _bstr_t ToUnit, _bstr_t FromValue ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ConvertDate(FromUnit, ToUnit, FromValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgConversionUtility::ConvertQuantityArray ( _bstr_t DimensionName, _bstr_t FromUnit, _bstr_t ToUnit, SAFEARRAY * * Values ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertQuantityArray(DimensionName, FromUnit, ToUnit, Values, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgConversionUtility::ConvertDateArray ( _bstr_t FromUnit, _bstr_t ToUnit, SAFEARRAY * * FromValues ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertDateArray(FromUnit, ToUnit, FromValues, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgQuantityPtr _IAgConversionUtility::NewQuantity ( _bstr_t Dimension, _bstr_t UnitAbbrv, double Value ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_NewQuantity(Dimension, UnitAbbrv, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgDatePtr _IAgConversionUtility::NewDate ( _bstr_t UnitAbbrv, _bstr_t Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_NewDate(UnitAbbrv, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgPositionPtr _IAgConversionUtility::NewPositionOnEarth ( ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_NewPositionOnEarth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

SAFEARRAY * _IAgConversionUtility::ConvertPositionArray ( enum AgEPositionType PositionType, SAFEARRAY * * PositionArray, enum AgEPositionType ConvertTo ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertPositionArray(PositionType, PositionArray, ConvertTo, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgDirectionPtr _IAgConversionUtility::NewDirection ( ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_NewDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

IAgOrientationPtr _IAgConversionUtility::NewOrientation ( ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_NewOrientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

IAgOrbitStatePtr _IAgConversionUtility::NewOrbitStateOnEarth ( ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_NewOrbitStateOnEarth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

IAgPositionPtr _IAgConversionUtility::NewPositionOnCB ( _bstr_t CentralBodyName ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_NewPositionOnCB(CentralBodyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

IAgOrbitStatePtr _IAgConversionUtility::NewOrbitStateOnCB ( _bstr_t CentralBodyName ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_NewOrbitStateOnCB(CentralBodyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

HRESULT _IAgConversionUtility::QueryDirectionCosineMatrix ( struct IAgOrientation * InputOrientation, struct IAgCartesian3Vector * * pX, struct IAgCartesian3Vector * * pY, struct IAgCartesian3Vector * * pZ ) {
    HRESULT _hr = raw_QueryDirectionCosineMatrix(InputOrientation, pX, pY, pZ);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgConversionUtility::QueryDirectionCosineMatrixArray ( struct IAgOrientation * InputOrientation ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryDirectionCosineMatrixArray(InputOrientation, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCartesian3VectorPtr _IAgConversionUtility::NewCartesian3Vector ( ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

IAgCartesian3VectorPtr _IAgConversionUtility::NewCartesian3VectorFromDirection ( struct IAgDirection * InputDirection ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3VectorFromDirection(InputDirection, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

IAgCartesian3VectorPtr _IAgConversionUtility::NewCartesian3VectorFromPosition ( struct IAgPosition * InputPosition ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3VectorFromPosition(InputPosition, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgConversionUtility wrapper method implementations
//

double IAgConversionUtility::ConvertQuantity ( _bstr_t DimensionName, _bstr_t FromUnit, _bstr_t ToUnit, double FromValue ) {
    double _result = 0;
    HRESULT _hr = raw_ConvertQuantity(DimensionName, FromUnit, ToUnit, FromValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgConversionUtility::ConvertDate ( _bstr_t FromUnit, _bstr_t ToUnit, _bstr_t FromValue ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ConvertDate(FromUnit, ToUnit, FromValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * IAgConversionUtility::ConvertQuantityArray ( _bstr_t DimensionName, _bstr_t FromUnit, _bstr_t ToUnit, SAFEARRAY * * QuantityValues ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertQuantityArray(DimensionName, FromUnit, ToUnit, QuantityValues, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgConversionUtility::ConvertDateArray ( _bstr_t FromUnit, _bstr_t ToUnit, SAFEARRAY * * FromValues ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertDateArray(FromUnit, ToUnit, FromValues, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgQuantityPtr IAgConversionUtility::NewQuantity ( _bstr_t Dimension, _bstr_t UnitAbbrv, double Value ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_NewQuantity(Dimension, UnitAbbrv, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgDatePtr IAgConversionUtility::NewDate ( _bstr_t UnitAbbrv, _bstr_t Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_NewDate(UnitAbbrv, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgPositionPtr IAgConversionUtility::NewPositionOnEarth ( ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_NewPositionOnEarth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

SAFEARRAY * IAgConversionUtility::ConvertPositionArray ( enum AgEPositionType PositionType, SAFEARRAY * * PositionArray, enum AgEPositionType ConvertTo ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertPositionArray(PositionType, PositionArray, ConvertTo, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgDirectionPtr IAgConversionUtility::NewDirection ( ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_NewDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

IAgOrientationPtr IAgConversionUtility::NewOrientation ( ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_NewOrientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

IAgOrbitStatePtr IAgConversionUtility::NewOrbitStateOnEarth ( ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_NewOrbitStateOnEarth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

IAgPositionPtr IAgConversionUtility::NewPositionOnCB ( _bstr_t CentralBodyName ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_NewPositionOnCB(CentralBodyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

IAgOrbitStatePtr IAgConversionUtility::NewOrbitStateOnCB ( _bstr_t CentralBodyName ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_NewOrbitStateOnCB(CentralBodyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

HRESULT IAgConversionUtility::QueryDirectionCosineMatrix ( struct IAgOrientation * InputOrientation, struct IAgCartesian3Vector * * pX, struct IAgCartesian3Vector * * pY, struct IAgCartesian3Vector * * pZ ) {
    HRESULT _hr = raw_QueryDirectionCosineMatrix(InputOrientation, pX, pY, pZ);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgConversionUtility::QueryDirectionCosineMatrixArray ( struct IAgOrientation * InputOrientation ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryDirectionCosineMatrixArray(InputOrientation, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCartesian3VectorPtr IAgConversionUtility::NewCartesian3Vector ( ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

IAgCartesian3VectorPtr IAgConversionUtility::NewCartesian3VectorFromDirection ( struct IAgDirection * InputDirection ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3VectorFromDirection(InputDirection, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

IAgCartesian3VectorPtr IAgConversionUtility::NewCartesian3VectorFromPosition ( struct IAgPosition * InputPosition ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3VectorFromPosition(InputPosition, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

//
// interface _IAgQuantity wrapper method implementations
//

_bstr_t _IAgQuantity::GetDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgQuantity::GetUnit ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Unit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgQuantity::ConvertToUnit ( _bstr_t UnitAbbrv ) {
    HRESULT _hr = raw_ConvertToUnit(UnitAbbrv);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

double _IAgQuantity::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgQuantity::PutValue ( double pValue ) {
    HRESULT _hr = put_Value(pValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgQuantityPtr _IAgQuantity::Add ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Add(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr _IAgQuantity::Subtract ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Subtract(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr _IAgQuantity::MultiplyQty ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_MultiplyQty(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr _IAgQuantity::DivideQty ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_DivideQty(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

//
// interface _IAgDate wrapper method implementations
//

_bstr_t _IAgDate::Format ( _bstr_t Unit ) {
    BSTR _result = 0;
    HRESULT _hr = raw_Format(Unit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgDate::SetDate ( _bstr_t Unit, _bstr_t Value ) {
    HRESULT _hr = raw_SetDate(Unit, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

DATE _IAgDate::GetOLEDate ( ) {
    DATE _result = 0;
    HRESULT _hr = get_OLEDate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDate::PutOLEDate ( DATE pDate ) {
    HRESULT _hr = put_OLEDate(pDate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long _IAgDate::GetWholeDays ( ) {
    long _result = 0;
    HRESULT _hr = get_WholeDays(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDate::PutWholeDays ( long pVal ) {
    HRESULT _hr = put_WholeDays(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgDate::GetSecIntoDay ( ) {
    double _result = 0;
    HRESULT _hr = get_SecIntoDay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDate::PutSecIntoDay ( double pVal ) {
    HRESULT _hr = put_SecIntoDay(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long _IAgDate::GetWholeDaysUTC ( ) {
    long _result = 0;
    HRESULT _hr = get_WholeDaysUTC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDate::PutWholeDaysUTC ( long pVal ) {
    HRESULT _hr = put_WholeDaysUTC(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgDate::GetSecIntoDayUTC ( ) {
    double _result = 0;
    HRESULT _hr = get_SecIntoDayUTC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDate::PutSecIntoDayUTC ( double pVal ) {
    HRESULT _hr = put_SecIntoDayUTC(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgDatePtr _IAgDate::Add ( _bstr_t Unit, double Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_Add(Unit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgDatePtr _IAgDate::Subtract ( _bstr_t Unit, double Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_Subtract(Unit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgQuantityPtr _IAgDate::Span ( struct IAgDate * Date ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Span(Date, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

//
// interface IAgComponentInfo wrapper method implementations
//

_bstr_t IAgComponentInfo::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgComponentInfo::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgComponentInfo::GetUserComment ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UserComment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgComponentInfo::PutUserComment ( _bstr_t pVal ) {
    HRESULT _hr = put_UserComment(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgComponentInfo::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL IAgComponentInfo::IsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgComponentInfoCollection wrapper method implementations
//

IAgComponentInfoPtr IAgComponentInfoCollection::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgComponentInfo * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgComponentInfoPtr(_result, false);
}

IUnknownPtr IAgComponentInfoCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long IAgComponentInfoCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgComponentInfoCollectionPtr IAgComponentInfoCollection::GetFolder ( const _variant_t & IndexOrName ) {
    struct IAgComponentInfoCollection * _result = 0;
    HRESULT _hr = raw_GetFolder(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgComponentInfoCollectionPtr(_result, false);
}

long IAgComponentInfoCollection::GetFolderCount ( ) {
    long _result = 0;
    HRESULT _hr = get_FolderCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgComponentInfoCollection::GetAvailableFolders ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableFolders(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgComponentInfoCollection::GetFolderName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FolderName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface _IAgComponentDirectory wrapper method implementations
//

IAgComponentInfoCollectionPtr _IAgComponentDirectory::GetComponents ( enum AgEComponent EComponent ) {
    struct IAgComponentInfoCollection * _result = 0;
    HRESULT _hr = raw_GetComponents(EComponent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgComponentInfoCollectionPtr(_result, false);
}

//
// interface IAgComponentDirectory wrapper method implementations
//

IAgComponentInfoCollectionPtr IAgComponentDirectory::GetComponents ( enum AgEComponent EComponent ) {
    struct IAgComponentInfoCollection * _result = 0;
    HRESULT _hr = raw_GetComponents(EComponent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgComponentInfoCollectionPtr(_result, false);
}

//
// interface _IAgPosition wrapper method implementations
//

IAgPositionPtr _IAgPosition::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgPosition::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgPosition::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgPosition::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgPosition::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPosition::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPosition::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPosition::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPosition::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCartesian wrapper method implementations
//

double _IAgCartesian::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian::PutX ( double pVal ) {
    HRESULT _hr = put_X(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCartesian::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian::PutY ( double pVal ) {
    HRESULT _hr = put_Y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCartesian::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCartesian::SetValues ( double X, double Y, double Z ) {
    HRESULT _hr = raw_SetValues(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgPositionPtr _IAgCartesian::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgCartesian::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCartesian::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgCartesian::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgCartesian::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCartesian::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCartesian::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCartesian::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCartesian::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCartesian wrapper method implementations
//

double IAgCartesian::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian::PutX ( double pVal ) {
    HRESULT _hr = put_X(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCartesian::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian::PutY ( double pVal ) {
    HRESULT _hr = put_Y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCartesian::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCartesian::SetValues ( double X, double Y, double Z ) {
    HRESULT _hr = raw_SetValues(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgGeodetic wrapper method implementations
//

_variant_t _IAgGeodetic::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgGeodetic::PutLat ( const _variant_t & pLat ) {
    HRESULT _hr = put_Lat(pLat);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgGeodetic::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgGeodetic::PutLon ( const _variant_t & pLon ) {
    HRESULT _hr = put_Lon(pLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgGeodetic::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgGeodetic::PutAlt ( double pAlt ) {
    HRESULT _hr = put_Alt(pAlt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgGeodetic::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgPositionPtr _IAgGeodetic::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgGeodetic::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgGeodetic::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgGeodetic::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgGeodetic::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeodetic::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeodetic::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeodetic::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeodetic::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgGeodetic wrapper method implementations
//

_variant_t IAgGeodetic::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgGeodetic::PutLat ( const _variant_t & pLat ) {
    HRESULT _hr = put_Lat(pLat);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgGeodetic::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgGeodetic::PutLon ( const _variant_t & pLon ) {
    HRESULT _hr = put_Lon(pLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgGeodetic::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgGeodetic::PutAlt ( double pAlt ) {
    HRESULT _hr = put_Alt(pAlt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgGeodetic::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgGeocentric wrapper method implementations
//

_variant_t _IAgGeocentric::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgGeocentric::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgGeocentric::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgGeocentric::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgGeocentric::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgGeocentric::PutAlt ( double pVal ) {
    HRESULT _hr = put_Alt(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgGeocentric::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgPositionPtr _IAgGeocentric::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgGeocentric::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgGeocentric::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgGeocentric::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgGeocentric::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeocentric::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeocentric::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeocentric::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeocentric::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgGeocentric wrapper method implementations
//

_variant_t IAgGeocentric::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgGeocentric::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgGeocentric::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgGeocentric::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgGeocentric::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgGeocentric::PutAlt ( double pVal ) {
    HRESULT _hr = put_Alt(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgGeocentric::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgPlanetodetic wrapper method implementations
//

_variant_t _IAgPlanetodetic::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgPlanetodetic::PutLat ( const _variant_t & pLat ) {
    HRESULT _hr = put_Lat(pLat);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgPlanetodetic::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgPlanetodetic::PutLon ( const _variant_t & pLon ) {
    HRESULT _hr = put_Lon(pLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgPlanetodetic::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgPlanetodetic::PutAlt ( double pAlt ) {
    HRESULT _hr = put_Alt(pAlt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgPositionPtr _IAgPlanetodetic::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgPlanetodetic::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgPlanetodetic::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgPlanetodetic::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgPlanetodetic::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetodetic::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetodetic::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetodetic::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetodetic::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgPlanetodetic wrapper method implementations
//

_variant_t IAgPlanetodetic::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgPlanetodetic::PutLat ( const _variant_t & pLat ) {
    HRESULT _hr = put_Lat(pLat);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgPlanetodetic::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgPlanetodetic::PutLon ( const _variant_t & pLon ) {
    HRESULT _hr = put_Lon(pLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgPlanetodetic::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgPlanetodetic::PutAlt ( double pAlt ) {
    HRESULT _hr = put_Alt(pAlt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgPlanetocentric wrapper method implementations
//

_variant_t _IAgPlanetocentric::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgPlanetocentric::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgPlanetocentric::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgPlanetocentric::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgPlanetocentric::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgPlanetocentric::PutAlt ( double pVal ) {
    HRESULT _hr = put_Alt(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgPositionPtr _IAgPlanetocentric::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgPlanetocentric::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgPlanetocentric::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgPlanetocentric::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgPlanetocentric::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetocentric::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetocentric::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetocentric::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetocentric::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgPlanetocentric wrapper method implementations
//

_variant_t IAgPlanetocentric::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgPlanetocentric::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgPlanetocentric::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgPlanetocentric::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgPlanetocentric::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgPlanetocentric::PutAlt ( double pVal ) {
    HRESULT _hr = put_Alt(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgSpherical wrapper method implementations
//

_variant_t _IAgSpherical::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgSpherical::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgSpherical::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgSpherical::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgSpherical::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgSpherical::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgSpherical::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgPositionPtr _IAgSpherical::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgSpherical::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgSpherical::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgSpherical::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgSpherical::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgSpherical::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgSpherical::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgSpherical::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgSpherical::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgSpherical wrapper method implementations
//

_variant_t IAgSpherical::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgSpherical::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgSpherical::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgSpherical::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgSpherical::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgSpherical::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgSpherical::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCylindrical wrapper method implementations
//

double _IAgCylindrical::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCylindrical::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCylindrical::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCylindrical::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgCylindrical::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCylindrical::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCylindrical::SetValues ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_SetValues(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgPositionPtr _IAgCylindrical::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgCylindrical::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCylindrical::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgCylindrical::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgCylindrical::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCylindrical::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCylindrical::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCylindrical::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCylindrical::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCylindrical wrapper method implementations
//

double IAgCylindrical::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCylindrical::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCylindrical::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCylindrical::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgCylindrical::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCylindrical::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCylindrical::SetValues ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_SetValues(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgDirection wrapper method implementations
//

IAgDirectionPtr _IAgDirection::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType _IAgDirection::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgDirection::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgDirection::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirection::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirection::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirection::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgDirectionEuler wrapper method implementations
//

_variant_t _IAgDirectionEuler::GetB ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionEuler::PutB ( const _variant_t & pVal ) {
    HRESULT _hr = put_B(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgDirectionEuler::GetC ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionEuler::PutC ( const _variant_t & pVal ) {
    HRESULT _hr = put_C(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEEulerDirectionSequence _IAgDirectionEuler::GetSequence ( ) {
    enum AgEEulerDirectionSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDirectionEuler::PutSequence ( enum AgEEulerDirectionSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgDirectionEuler::SetValues ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_SetValues(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgDirectionPtr _IAgDirectionEuler::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType _IAgDirectionEuler::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgDirectionEuler::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgDirectionEuler::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionEuler::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionEuler::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionEuler::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgDirectionEuler wrapper method implementations
//

_variant_t IAgDirectionEuler::GetB ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionEuler::PutB ( const _variant_t & pVal ) {
    HRESULT _hr = put_B(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgDirectionEuler::GetC ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionEuler::PutC ( const _variant_t & pVal ) {
    HRESULT _hr = put_C(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEEulerDirectionSequence IAgDirectionEuler::GetSequence ( ) {
    enum AgEEulerDirectionSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDirectionEuler::PutSequence ( enum AgEEulerDirectionSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgDirectionEuler::SetValues ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_SetValues(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgDirectionPR wrapper method implementations
//

_variant_t _IAgDirectionPR::GetPitch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Pitch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionPR::PutPitch ( const _variant_t & pVal ) {
    HRESULT _hr = put_Pitch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgDirectionPR::GetRoll ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Roll(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionPR::PutRoll ( const _variant_t & pVal ) {
    HRESULT _hr = put_Roll(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEPRSequence _IAgDirectionPR::GetSequence ( ) {
    enum AgEPRSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDirectionPR::PutSequence ( enum AgEPRSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgDirectionPR::SetValues ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_SetValues(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgDirectionPtr _IAgDirectionPR::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType _IAgDirectionPR::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgDirectionPR::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgDirectionPR::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionPR::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionPR::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionPR::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgDirectionPR wrapper method implementations
//

_variant_t IAgDirectionPR::GetPitch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Pitch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionPR::PutPitch ( const _variant_t & pVal ) {
    HRESULT _hr = put_Pitch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgDirectionPR::GetRoll ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Roll(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionPR::PutRoll ( const _variant_t & pVal ) {
    HRESULT _hr = put_Roll(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEPRSequence IAgDirectionPR::GetSequence ( ) {
    enum AgEPRSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDirectionPR::PutSequence ( enum AgEPRSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgDirectionPR::SetValues ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_SetValues(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgDirectionRADec wrapper method implementations
//

_variant_t _IAgDirectionRADec::GetDec ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Dec(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionRADec::PutDec ( const _variant_t & pVal ) {
    HRESULT _hr = put_Dec(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgDirectionRADec::GetRA ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_RA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionRADec::PutRA ( const _variant_t & pVal ) {
    HRESULT _hr = put_RA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgDirectionRADec::SetValues ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_SetValues(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgDirectionPtr _IAgDirectionRADec::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType _IAgDirectionRADec::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgDirectionRADec::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgDirectionRADec::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionRADec::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionRADec::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionRADec::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgDirectionRADec wrapper method implementations
//

_variant_t IAgDirectionRADec::GetDec ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Dec(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionRADec::PutDec ( const _variant_t & pVal ) {
    HRESULT _hr = put_Dec(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgDirectionRADec::GetRA ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_RA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionRADec::PutRA ( const _variant_t & pVal ) {
    HRESULT _hr = put_RA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgDirectionRADec::SetValues ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_SetValues(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgDirectionXYZ wrapper method implementations
//

double _IAgDirectionXYZ::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDirectionXYZ::PutX ( double pVal ) {
    HRESULT _hr = put_X(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgDirectionXYZ::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDirectionXYZ::PutY ( double pVal ) {
    HRESULT _hr = put_Y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgDirectionXYZ::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDirectionXYZ::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgDirectionXYZ::SetValues ( double X, double Y, double Z ) {
    HRESULT _hr = raw_SetValues(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgDirectionPtr _IAgDirectionXYZ::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType _IAgDirectionXYZ::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgDirectionXYZ::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgDirectionXYZ::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionXYZ::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionXYZ::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionXYZ::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgDirectionXYZ wrapper method implementations
//

double IAgDirectionXYZ::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDirectionXYZ::PutX ( double pVal ) {
    HRESULT _hr = put_X(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgDirectionXYZ::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDirectionXYZ::PutY ( double pVal ) {
    HRESULT _hr = put_Y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgDirectionXYZ::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDirectionXYZ::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgDirectionXYZ::SetValues ( double X, double Y, double Z ) {
    HRESULT _hr = raw_SetValues(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgOrientation wrapper method implementations
//

IAgOrientationPtr _IAgOrientation::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgOrientation::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrientation::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgOrientation::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientation::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientation::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientation::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgOrientationAzEl wrapper method implementations
//

_variant_t _IAgOrientationAzEl::GetAzimuth ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Azimuth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationAzEl::PutAzimuth ( const _variant_t & pVal ) {
    HRESULT _hr = put_Azimuth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationAzEl::GetElevation ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Elevation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationAzEl::PutElevation ( const _variant_t & pVal ) {
    HRESULT _hr = put_Elevation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEAzElAboutBoresight _IAgOrientationAzEl::GetAboutBoresight ( ) {
    enum AgEAzElAboutBoresight _result;
    HRESULT _hr = get_AboutBoresight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationAzEl::PutAboutBoresight ( enum AgEAzElAboutBoresight pVal ) {
    HRESULT _hr = put_AboutBoresight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgOrientationAzEl::SetValues ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_SetValues(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgOrientationAzEl::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgOrientationAzEl::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrientationAzEl::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgOrientationAzEl::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationAzEl::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationAzEl::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationAzEl::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgOrientationAzEl wrapper method implementations
//

_variant_t IAgOrientationAzEl::GetAzimuth ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Azimuth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationAzEl::PutAzimuth ( const _variant_t & pVal ) {
    HRESULT _hr = put_Azimuth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationAzEl::GetElevation ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Elevation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationAzEl::PutElevation ( const _variant_t & pVal ) {
    HRESULT _hr = put_Elevation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEAzElAboutBoresight IAgOrientationAzEl::GetAboutBoresight ( ) {
    enum AgEAzElAboutBoresight _result;
    HRESULT _hr = get_AboutBoresight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationAzEl::PutAboutBoresight ( enum AgEAzElAboutBoresight pVal ) {
    HRESULT _hr = put_AboutBoresight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgOrientationAzEl::SetValues ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_SetValues(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgOrientationEulerAngles wrapper method implementations
//

enum AgEEulerOrientationSequence _IAgOrientationEulerAngles::GetSequence ( ) {
    enum AgEEulerOrientationSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationEulerAngles::PutSequence ( enum AgEEulerOrientationSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationEulerAngles::GetA ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_A(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationEulerAngles::PutA ( const _variant_t & pVal ) {
    HRESULT _hr = put_A(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationEulerAngles::GetB ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationEulerAngles::PutB ( const _variant_t & pVal ) {
    HRESULT _hr = put_B(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationEulerAngles::GetC ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationEulerAngles::PutC ( const _variant_t & pVal ) {
    HRESULT _hr = put_C(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgOrientationEulerAngles::SetValues ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_SetValues(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgOrientationEulerAngles::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgOrientationEulerAngles::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrientationEulerAngles::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgOrientationEulerAngles::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationEulerAngles::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationEulerAngles::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationEulerAngles::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgOrientationEulerAngles wrapper method implementations
//

enum AgEEulerOrientationSequence IAgOrientationEulerAngles::GetSequence ( ) {
    enum AgEEulerOrientationSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationEulerAngles::PutSequence ( enum AgEEulerOrientationSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationEulerAngles::GetA ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_A(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationEulerAngles::PutA ( const _variant_t & pVal ) {
    HRESULT _hr = put_A(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationEulerAngles::GetB ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationEulerAngles::PutB ( const _variant_t & pVal ) {
    HRESULT _hr = put_B(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationEulerAngles::GetC ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationEulerAngles::PutC ( const _variant_t & pVal ) {
    HRESULT _hr = put_C(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgOrientationEulerAngles::SetValues ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_SetValues(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgOrientationQuaternion wrapper method implementations
//

double _IAgOrientationQuaternion::GetQX ( ) {
    double _result = 0;
    HRESULT _hr = get_QX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationQuaternion::PutQX ( double pVal ) {
    HRESULT _hr = put_QX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrientationQuaternion::GetQY ( ) {
    double _result = 0;
    HRESULT _hr = get_QY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationQuaternion::PutQY ( double pVal ) {
    HRESULT _hr = put_QY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrientationQuaternion::GetQZ ( ) {
    double _result = 0;
    HRESULT _hr = get_QZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationQuaternion::PutQZ ( double pVal ) {
    HRESULT _hr = put_QZ(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrientationQuaternion::GetQS ( ) {
    double _result = 0;
    HRESULT _hr = get_QS(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationQuaternion::PutQS ( double pVal ) {
    HRESULT _hr = put_QS(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgOrientationQuaternion::SetValues ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_SetValues(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgOrientationQuaternion::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgOrientationQuaternion::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrientationQuaternion::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgOrientationQuaternion::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationQuaternion::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationQuaternion::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationQuaternion::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgOrientationQuaternion wrapper method implementations
//

double IAgOrientationQuaternion::GetQX ( ) {
    double _result = 0;
    HRESULT _hr = get_QX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationQuaternion::PutQX ( double pVal ) {
    HRESULT _hr = put_QX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrientationQuaternion::GetQY ( ) {
    double _result = 0;
    HRESULT _hr = get_QY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationQuaternion::PutQY ( double pVal ) {
    HRESULT _hr = put_QY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrientationQuaternion::GetQZ ( ) {
    double _result = 0;
    HRESULT _hr = get_QZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationQuaternion::PutQZ ( double pVal ) {
    HRESULT _hr = put_QZ(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrientationQuaternion::GetQS ( ) {
    double _result = 0;
    HRESULT _hr = get_QS(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationQuaternion::PutQS ( double pVal ) {
    HRESULT _hr = put_QS(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgOrientationQuaternion::SetValues ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_SetValues(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgOrientationYPRAngles wrapper method implementations
//

enum AgEYPRAnglesSequence _IAgOrientationYPRAngles::GetSequence ( ) {
    enum AgEYPRAnglesSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationYPRAngles::PutSequence ( enum AgEYPRAnglesSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationYPRAngles::GetYaw ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Yaw(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationYPRAngles::PutYaw ( const _variant_t & pVal ) {
    HRESULT _hr = put_Yaw(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationYPRAngles::GetPitch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Pitch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationYPRAngles::PutPitch ( const _variant_t & pVal ) {
    HRESULT _hr = put_Pitch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationYPRAngles::GetRoll ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Roll(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationYPRAngles::PutRoll ( const _variant_t & pVal ) {
    HRESULT _hr = put_Roll(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgOrientationYPRAngles::SetValues ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_SetValues(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgOrientationYPRAngles::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgOrientationYPRAngles::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrientationYPRAngles::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgOrientationYPRAngles::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationYPRAngles::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationYPRAngles::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationYPRAngles::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgOrientationYPRAngles wrapper method implementations
//

enum AgEYPRAnglesSequence IAgOrientationYPRAngles::GetSequence ( ) {
    enum AgEYPRAnglesSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationYPRAngles::PutSequence ( enum AgEYPRAnglesSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationYPRAngles::GetYaw ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Yaw(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationYPRAngles::PutYaw ( const _variant_t & pVal ) {
    HRESULT _hr = put_Yaw(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationYPRAngles::GetPitch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Pitch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationYPRAngles::PutPitch ( const _variant_t & pVal ) {
    HRESULT _hr = put_Pitch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationYPRAngles::GetRoll ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Roll(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationYPRAngles::PutRoll ( const _variant_t & pVal ) {
    HRESULT _hr = put_Roll(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgOrientationYPRAngles::SetValues ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_SetValues(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgOrbitState wrapper method implementations
//

IAgOrbitStatePtr _IAgOrbitState::ConvertTo ( enum AgEOrbitStateType Type ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

enum AgEOrbitStateType _IAgOrbitState::GetOrbitStateType ( ) {
    enum AgEOrbitStateType _result;
    HRESULT _hr = get_OrbitStateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrbitState::Assign ( struct IAgOrbitState * pOrbitState ) {
    HRESULT _hr = raw_Assign(pOrbitState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignClassical ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double Eccentricity, double Inclination, double ArgOfPerigee, double RAAN, double MeanAnomaly ) {
    HRESULT _hr = raw_AssignClassical(ECoordinateSystem, SemiMajorAxis, Eccentricity, Inclination, ArgOfPerigee, RAAN, MeanAnomaly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignCartesian ( enum AgECoordinateSystem ECoordinateSystem, double XPosition, double YPosition, double ZPosition, double XVelocity, double YVelocity, double ZVelocity ) {
    HRESULT _hr = raw_AssignCartesian(ECoordinateSystem, XPosition, YPosition, ZPosition, XVelocity, YVelocity, ZVelocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignGeodetic ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double LatitudeRate, double LongitudeRate, double AltitudeRate ) {
    HRESULT _hr = raw_AssignGeodetic(ECoordinateSystem, Latitude, Longitude, Altitude, LatitudeRate, LongitudeRate, AltitudeRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignEquinoctial ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon, enum AgEEquinoctialFormulation EquinoctialFormulation ) {
    HRESULT _hr = raw_AssignEquinoctial(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon, EquinoctialFormulation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignMixedSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignMixedSpherical(ECoordinateSystem, Latitude, Longitude, Altitude, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Radius, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignSpherical(ECoordinateSystem, Latitude, Longitude, Radius, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgOrbitState::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t _IAgOrbitState::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrbitState::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgOrbitStateCoordinateSystem wrapper method implementations
//

enum AgECoordinateSystem _IAgOrbitStateCoordinateSystem::GetType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgOrbitStateCoordinateSystem::GetEpoch ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgOrbitStateCoordinateSystem::PutEpoch ( _bstr_t pVal ) {
    HRESULT _hr = put_Epoch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgOrbitStateCoordinateSystem wrapper method implementations
//

enum AgECoordinateSystem IAgOrbitStateCoordinateSystem::GetType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgOrbitStateCoordinateSystem::GetEpoch ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgOrbitStateCoordinateSystem::PutEpoch ( _bstr_t pVal ) {
    HRESULT _hr = put_Epoch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgOrbitStateCartesian wrapper method implementations
//

enum AgECoordinateSystem _IAgOrbitStateCartesian::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateCartesian::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr _IAgOrbitStateCartesian::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

double _IAgOrbitStateCartesian::GetXPosition ( ) {
    double _result = 0;
    HRESULT _hr = get_XPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateCartesian::PutXPosition ( double pVal ) {
    HRESULT _hr = put_XPosition(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateCartesian::GetYPosition ( ) {
    double _result = 0;
    HRESULT _hr = get_YPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateCartesian::PutYPosition ( double pVal ) {
    HRESULT _hr = put_YPosition(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateCartesian::GetZPosition ( ) {
    double _result = 0;
    HRESULT _hr = get_ZPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateCartesian::PutZPosition ( double pVal ) {
    HRESULT _hr = put_ZPosition(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateCartesian::GetXVelocity ( ) {
    double _result = 0;
    HRESULT _hr = get_XVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateCartesian::PutXVelocity ( double pVal ) {
    HRESULT _hr = put_XVelocity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateCartesian::GetYVelocity ( ) {
    double _result = 0;
    HRESULT _hr = get_YVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateCartesian::PutYVelocity ( double pVal ) {
    HRESULT _hr = put_YVelocity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateCartesian::GetZVelocity ( ) {
    double _result = 0;
    HRESULT _hr = get_ZVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateCartesian::PutZVelocity ( double pVal ) {
    HRESULT _hr = put_ZVelocity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * _IAgOrbitStateCartesian::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgOrbitStatePtr _IAgOrbitStateCartesian::ConvertTo ( enum AgEOrbitStateType Type ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

enum AgEOrbitStateType _IAgOrbitStateCartesian::GetOrbitStateType ( ) {
    enum AgEOrbitStateType _result;
    HRESULT _hr = get_OrbitStateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrbitStateCartesian::Assign ( struct IAgOrbitState * pOrbitState ) {
    HRESULT _hr = raw_Assign(pOrbitState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateCartesian::AssignClassical ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double Eccentricity, double Inclination, double ArgOfPerigee, double RAAN, double MeanAnomaly ) {
    HRESULT _hr = raw_AssignClassical(ECoordinateSystem, SemiMajorAxis, Eccentricity, Inclination, ArgOfPerigee, RAAN, MeanAnomaly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateCartesian::AssignCartesian ( enum AgECoordinateSystem ECoordinateSystem, double XPosition, double YPosition, double ZPosition, double XVelocity, double YVelocity, double ZVelocity ) {
    HRESULT _hr = raw_AssignCartesian(ECoordinateSystem, XPosition, YPosition, ZPosition, XVelocity, YVelocity, ZVelocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateCartesian::AssignGeodetic ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double LatitudeRate, double LongitudeRate, double AltitudeRate ) {
    HRESULT _hr = raw_AssignGeodetic(ECoordinateSystem, Latitude, Longitude, Altitude, LatitudeRate, LongitudeRate, AltitudeRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateCartesian::AssignEquinoctial ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon, enum AgEEquinoctialFormulation EquinoctialFormulation ) {
    HRESULT _hr = raw_AssignEquinoctial(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon, EquinoctialFormulation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateCartesian::AssignMixedSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignMixedSpherical(ECoordinateSystem, Latitude, Longitude, Altitude, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateCartesian::AssignSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Radius, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignSpherical(ECoordinateSystem, Latitude, Longitude, Radius, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgOrbitStateCartesian::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t _IAgOrbitStateCartesian::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrbitStateCartesian::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgOrbitStateCartesian wrapper method implementations
//

enum AgECoordinateSystem IAgOrbitStateCartesian::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateCartesian::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr IAgOrbitStateCartesian::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

double IAgOrbitStateCartesian::GetXPosition ( ) {
    double _result = 0;
    HRESULT _hr = get_XPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateCartesian::PutXPosition ( double pVal ) {
    HRESULT _hr = put_XPosition(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateCartesian::GetYPosition ( ) {
    double _result = 0;
    HRESULT _hr = get_YPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateCartesian::PutYPosition ( double pVal ) {
    HRESULT _hr = put_YPosition(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateCartesian::GetZPosition ( ) {
    double _result = 0;
    HRESULT _hr = get_ZPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateCartesian::PutZPosition ( double pVal ) {
    HRESULT _hr = put_ZPosition(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateCartesian::GetXVelocity ( ) {
    double _result = 0;
    HRESULT _hr = get_XVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateCartesian::PutXVelocity ( double pVal ) {
    HRESULT _hr = put_XVelocity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateCartesian::GetYVelocity ( ) {
    double _result = 0;
    HRESULT _hr = get_YVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateCartesian::PutYVelocity ( double pVal ) {
    HRESULT _hr = put_YVelocity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateCartesian::GetZVelocity ( ) {
    double _result = 0;
    HRESULT _hr = get_ZVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateCartesian::PutZVelocity ( double pVal ) {
    HRESULT _hr = put_ZVelocity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IAgOrbitStateCartesian::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgClassicalSizeShapeAltitude wrapper method implementations
//

double _IAgClassicalSizeShapeAltitude::GetApogeeAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_ApogeeAltitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalSizeShapeAltitude::PutApogeeAltitude ( double pVal ) {
    HRESULT _hr = put_ApogeeAltitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgClassicalSizeShapeAltitude::GetPerigeeAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_PerigeeAltitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalSizeShapeAltitude::PutPerigeeAltitude ( double pVal ) {
    HRESULT _hr = put_PerigeeAltitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgClassicalSizeShapeAltitude wrapper method implementations
//

double IAgClassicalSizeShapeAltitude::GetApogeeAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_ApogeeAltitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalSizeShapeAltitude::PutApogeeAltitude ( double pVal ) {
    HRESULT _hr = put_ApogeeAltitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgClassicalSizeShapeAltitude::GetPerigeeAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_PerigeeAltitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalSizeShapeAltitude::PutPerigeeAltitude ( double pVal ) {
    HRESULT _hr = put_PerigeeAltitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgClassicalSizeShapeMeanMotion wrapper method implementations
//

double _IAgClassicalSizeShapeMeanMotion::GetMeanMotion ( ) {
    double _result = 0;
    HRESULT _hr = get_MeanMotion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalSizeShapeMeanMotion::PutMeanMotion ( double pVal ) {
    HRESULT _hr = put_MeanMotion(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgClassicalSizeShapeMeanMotion::GetEccentricity ( ) {
    double _result = 0;
    HRESULT _hr = get_Eccentricity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalSizeShapeMeanMotion::PutEccentricity ( double pVal ) {
    HRESULT _hr = put_Eccentricity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgClassicalSizeShapeMeanMotion wrapper method implementations
//

double IAgClassicalSizeShapeMeanMotion::GetMeanMotion ( ) {
    double _result = 0;
    HRESULT _hr = get_MeanMotion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalSizeShapeMeanMotion::PutMeanMotion ( double pVal ) {
    HRESULT _hr = put_MeanMotion(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgClassicalSizeShapeMeanMotion::GetEccentricity ( ) {
    double _result = 0;
    HRESULT _hr = get_Eccentricity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalSizeShapeMeanMotion::PutEccentricity ( double pVal ) {
    HRESULT _hr = put_Eccentricity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgClassicalSizeShapePeriod wrapper method implementations
//

double _IAgClassicalSizeShapePeriod::GetPeriod ( ) {
    double _result = 0;
    HRESULT _hr = get_Period(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalSizeShapePeriod::PutPeriod ( double pVal ) {
    HRESULT _hr = put_Period(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgClassicalSizeShapePeriod::GetEccentricity ( ) {
    double _result = 0;
    HRESULT _hr = get_Eccentricity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalSizeShapePeriod::PutEccentricity ( double pVal ) {
    HRESULT _hr = put_Eccentricity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgClassicalSizeShapePeriod wrapper method implementations
//

double IAgClassicalSizeShapePeriod::GetPeriod ( ) {
    double _result = 0;
    HRESULT _hr = get_Period(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalSizeShapePeriod::PutPeriod ( double pVal ) {
    HRESULT _hr = put_Period(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgClassicalSizeShapePeriod::GetEccentricity ( ) {
    double _result = 0;
    HRESULT _hr = get_Eccentricity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalSizeShapePeriod::PutEccentricity ( double pVal ) {
    HRESULT _hr = put_Eccentricity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgClassicalSizeShapeRadius wrapper method implementations
//

double _IAgClassicalSizeShapeRadius::GetApogeeRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_ApogeeRadius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalSizeShapeRadius::PutApogeeRadius ( double pVal ) {
    HRESULT _hr = put_ApogeeRadius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgClassicalSizeShapeRadius::GetPerigeeRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_PerigeeRadius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalSizeShapeRadius::PutPerigeeRadius ( double pVal ) {
    HRESULT _hr = put_PerigeeRadius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgClassicalSizeShapeRadius::SetSizeShapeRadius ( double ApogeeRadius, double PerigeeRadius ) {
    HRESULT _hr = raw_SetSizeShapeRadius(ApogeeRadius, PerigeeRadius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgClassicalSizeShapeRadius wrapper method implementations
//

double IAgClassicalSizeShapeRadius::GetApogeeRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_ApogeeRadius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalSizeShapeRadius::PutApogeeRadius ( double pVal ) {
    HRESULT _hr = put_ApogeeRadius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgClassicalSizeShapeRadius::GetPerigeeRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_PerigeeRadius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalSizeShapeRadius::PutPerigeeRadius ( double pVal ) {
    HRESULT _hr = put_PerigeeRadius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgClassicalSizeShapeRadius::SetSizeShapeRadius ( double ApogeeRadius, double PerigeeRadius ) {
    HRESULT _hr = raw_SetSizeShapeRadius(ApogeeRadius, PerigeeRadius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgClassicalSizeShapeSemimajorAxis wrapper method implementations
//

double _IAgClassicalSizeShapeSemimajorAxis::GetSemiMajorAxis ( ) {
    double _result = 0;
    HRESULT _hr = get_SemiMajorAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalSizeShapeSemimajorAxis::PutSemiMajorAxis ( double pVal ) {
    HRESULT _hr = put_SemiMajorAxis(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgClassicalSizeShapeSemimajorAxis::GetEccentricity ( ) {
    double _result = 0;
    HRESULT _hr = get_Eccentricity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalSizeShapeSemimajorAxis::PutEccentricity ( double pVal ) {
    HRESULT _hr = put_Eccentricity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgClassicalSizeShapeSemimajorAxis wrapper method implementations
//

double IAgClassicalSizeShapeSemimajorAxis::GetSemiMajorAxis ( ) {
    double _result = 0;
    HRESULT _hr = get_SemiMajorAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalSizeShapeSemimajorAxis::PutSemiMajorAxis ( double pVal ) {
    HRESULT _hr = put_SemiMajorAxis(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgClassicalSizeShapeSemimajorAxis::GetEccentricity ( ) {
    double _result = 0;
    HRESULT _hr = get_Eccentricity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalSizeShapeSemimajorAxis::PutEccentricity ( double pVal ) {
    HRESULT _hr = put_Eccentricity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgOrientationAscNodeLAN wrapper method implementations
//

double _IAgOrientationAscNodeLAN::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationAscNodeLAN::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgOrientationAscNodeLAN wrapper method implementations
//

double IAgOrientationAscNodeLAN::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationAscNodeLAN::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgOrientationAscNodeRAAN wrapper method implementations
//

double _IAgOrientationAscNodeRAAN::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationAscNodeRAAN::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgOrientationAscNodeRAAN wrapper method implementations
//

double IAgOrientationAscNodeRAAN::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationAscNodeRAAN::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgClassicalOrientation wrapper method implementations
//

double _IAgClassicalOrientation::GetInclination ( ) {
    double _result = 0;
    HRESULT _hr = get_Inclination(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalOrientation::PutInclination ( double pVal ) {
    HRESULT _hr = put_Inclination(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgClassicalOrientation::GetArgOfPerigee ( ) {
    double _result = 0;
    HRESULT _hr = get_ArgOfPerigee(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalOrientation::PutArgOfPerigee ( double pVal ) {
    HRESULT _hr = put_ArgOfPerigee(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEOrientationAscNode _IAgClassicalOrientation::GetAscNodeType ( ) {
    enum AgEOrientationAscNode _result;
    HRESULT _hr = get_AscNodeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalOrientation::PutAscNodeType ( enum AgEOrientationAscNode pVal ) {
    HRESULT _hr = put_AscNodeType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrientationAscNodePtr _IAgClassicalOrientation::GetAscNode ( ) {
    struct IAgOrientationAscNode * _result = 0;
    HRESULT _hr = get_AscNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationAscNodePtr(_result, false);
}

//
// interface IAgClassicalOrientation wrapper method implementations
//

double IAgClassicalOrientation::GetInclination ( ) {
    double _result = 0;
    HRESULT _hr = get_Inclination(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalOrientation::PutInclination ( double pVal ) {
    HRESULT _hr = put_Inclination(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgClassicalOrientation::GetArgOfPerigee ( ) {
    double _result = 0;
    HRESULT _hr = get_ArgOfPerigee(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalOrientation::PutArgOfPerigee ( double pVal ) {
    HRESULT _hr = put_ArgOfPerigee(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEOrientationAscNode IAgClassicalOrientation::GetAscNodeType ( ) {
    enum AgEOrientationAscNode _result;
    HRESULT _hr = get_AscNodeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalOrientation::PutAscNodeType ( enum AgEOrientationAscNode pVal ) {
    HRESULT _hr = put_AscNodeType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrientationAscNodePtr IAgClassicalOrientation::GetAscNode ( ) {
    struct IAgOrientationAscNode * _result = 0;
    HRESULT _hr = get_AscNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationAscNodePtr(_result, false);
}

//
// interface _IAgClassicalLocationArgumentOfLatitude wrapper method implementations
//

double _IAgClassicalLocationArgumentOfLatitude::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalLocationArgumentOfLatitude::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgClassicalLocationArgumentOfLatitude wrapper method implementations
//

double IAgClassicalLocationArgumentOfLatitude::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalLocationArgumentOfLatitude::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgClassicalLocationEccentricAnomaly wrapper method implementations
//

double _IAgClassicalLocationEccentricAnomaly::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalLocationEccentricAnomaly::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgClassicalLocationEccentricAnomaly wrapper method implementations
//

double IAgClassicalLocationEccentricAnomaly::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalLocationEccentricAnomaly::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgClassicalLocationMeanAnomaly wrapper method implementations
//

double _IAgClassicalLocationMeanAnomaly::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalLocationMeanAnomaly::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgClassicalLocationMeanAnomaly wrapper method implementations
//

double IAgClassicalLocationMeanAnomaly::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalLocationMeanAnomaly::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgClassicalLocationTimePastAN wrapper method implementations
//

double _IAgClassicalLocationTimePastAN::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalLocationTimePastAN::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgClassicalLocationTimePastAN wrapper method implementations
//

double IAgClassicalLocationTimePastAN::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalLocationTimePastAN::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgClassicalLocationTimePastPerigee wrapper method implementations
//

double _IAgClassicalLocationTimePastPerigee::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalLocationTimePastPerigee::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgClassicalLocationTimePastPerigee wrapper method implementations
//

double IAgClassicalLocationTimePastPerigee::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalLocationTimePastPerigee::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgClassicalLocationTrueAnomaly wrapper method implementations
//

double _IAgClassicalLocationTrueAnomaly::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgClassicalLocationTrueAnomaly::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgClassicalLocationTrueAnomaly wrapper method implementations
//

double IAgClassicalLocationTrueAnomaly::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgClassicalLocationTrueAnomaly::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgOrbitStateClassical wrapper method implementations
//

enum AgECoordinateSystem _IAgOrbitStateClassical::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateClassical::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr _IAgOrbitStateClassical::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

enum AgEClassicalSizeShape _IAgOrbitStateClassical::GetSizeShapeType ( ) {
    enum AgEClassicalSizeShape _result;
    HRESULT _hr = get_SizeShapeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateClassical::PutSizeShapeType ( enum AgEClassicalSizeShape pVal ) {
    HRESULT _hr = put_SizeShapeType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgClassicalSizeShapePtr _IAgOrbitStateClassical::GetSizeShape ( ) {
    struct IAgClassicalSizeShape * _result = 0;
    HRESULT _hr = get_SizeShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgClassicalSizeShapePtr(_result, false);
}

IAgClassicalOrientationPtr _IAgOrbitStateClassical::GetOrientation ( ) {
    struct IAgClassicalOrientation * _result = 0;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgClassicalOrientationPtr(_result, false);
}

enum AgEClassicalLocation _IAgOrbitStateClassical::GetLocationType ( ) {
    enum AgEClassicalLocation _result;
    HRESULT _hr = get_LocationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateClassical::PutLocationType ( enum AgEClassicalLocation pVal ) {
    HRESULT _hr = put_LocationType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgClassicalLocationPtr _IAgOrbitStateClassical::GetLocation ( ) {
    struct IAgClassicalLocation * _result = 0;
    HRESULT _hr = get_Location(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgClassicalLocationPtr(_result, false);
}

SAFEARRAY * _IAgOrbitStateClassical::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgOrbitStatePtr _IAgOrbitStateClassical::ConvertTo ( enum AgEOrbitStateType Type ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

enum AgEOrbitStateType _IAgOrbitStateClassical::GetOrbitStateType ( ) {
    enum AgEOrbitStateType _result;
    HRESULT _hr = get_OrbitStateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrbitStateClassical::Assign ( struct IAgOrbitState * pOrbitState ) {
    HRESULT _hr = raw_Assign(pOrbitState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateClassical::AssignClassical ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double Eccentricity, double Inclination, double ArgOfPerigee, double RAAN, double MeanAnomaly ) {
    HRESULT _hr = raw_AssignClassical(ECoordinateSystem, SemiMajorAxis, Eccentricity, Inclination, ArgOfPerigee, RAAN, MeanAnomaly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateClassical::AssignCartesian ( enum AgECoordinateSystem ECoordinateSystem, double XPosition, double YPosition, double ZPosition, double XVelocity, double YVelocity, double ZVelocity ) {
    HRESULT _hr = raw_AssignCartesian(ECoordinateSystem, XPosition, YPosition, ZPosition, XVelocity, YVelocity, ZVelocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateClassical::AssignGeodetic ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double LatitudeRate, double LongitudeRate, double AltitudeRate ) {
    HRESULT _hr = raw_AssignGeodetic(ECoordinateSystem, Latitude, Longitude, Altitude, LatitudeRate, LongitudeRate, AltitudeRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateClassical::AssignEquinoctial ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon, enum AgEEquinoctialFormulation EquinoctialFormulation ) {
    HRESULT _hr = raw_AssignEquinoctial(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon, EquinoctialFormulation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateClassical::AssignMixedSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignMixedSpherical(ECoordinateSystem, Latitude, Longitude, Altitude, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateClassical::AssignSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Radius, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignSpherical(ECoordinateSystem, Latitude, Longitude, Radius, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgOrbitStateClassical::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t _IAgOrbitStateClassical::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrbitStateClassical::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgOrbitStateClassical wrapper method implementations
//

enum AgECoordinateSystem IAgOrbitStateClassical::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateClassical::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr IAgOrbitStateClassical::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

enum AgEClassicalSizeShape IAgOrbitStateClassical::GetSizeShapeType ( ) {
    enum AgEClassicalSizeShape _result;
    HRESULT _hr = get_SizeShapeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateClassical::PutSizeShapeType ( enum AgEClassicalSizeShape pVal ) {
    HRESULT _hr = put_SizeShapeType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgClassicalSizeShapePtr IAgOrbitStateClassical::GetSizeShape ( ) {
    struct IAgClassicalSizeShape * _result = 0;
    HRESULT _hr = get_SizeShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgClassicalSizeShapePtr(_result, false);
}

IAgClassicalOrientationPtr IAgOrbitStateClassical::GetOrientation ( ) {
    struct IAgClassicalOrientation * _result = 0;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgClassicalOrientationPtr(_result, false);
}

enum AgEClassicalLocation IAgOrbitStateClassical::GetLocationType ( ) {
    enum AgEClassicalLocation _result;
    HRESULT _hr = get_LocationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateClassical::PutLocationType ( enum AgEClassicalLocation pVal ) {
    HRESULT _hr = put_LocationType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgClassicalLocationPtr IAgOrbitStateClassical::GetLocation ( ) {
    struct IAgClassicalLocation * _result = 0;
    HRESULT _hr = get_Location(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgClassicalLocationPtr(_result, false);
}

SAFEARRAY * IAgOrbitStateClassical::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgGeodeticSizeAltitude wrapper method implementations
//

double _IAgGeodeticSizeAltitude::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgGeodeticSizeAltitude::PutAltitude ( double pVal ) {
    HRESULT _hr = put_Altitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgGeodeticSizeAltitude::GetRate ( ) {
    double _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgGeodeticSizeAltitude::PutRate ( double pVal ) {
    HRESULT _hr = put_Rate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgGeodeticSizeAltitude wrapper method implementations
//

double IAgGeodeticSizeAltitude::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgGeodeticSizeAltitude::PutAltitude ( double pVal ) {
    HRESULT _hr = put_Altitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgGeodeticSizeAltitude::GetRate ( ) {
    double _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgGeodeticSizeAltitude::PutRate ( double pVal ) {
    HRESULT _hr = put_Rate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgGeodeticSizeRadius wrapper method implementations
//

double _IAgGeodeticSizeRadius::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgGeodeticSizeRadius::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgGeodeticSizeRadius::GetRate ( ) {
    double _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgGeodeticSizeRadius::PutRate ( double pVal ) {
    HRESULT _hr = put_Rate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgGeodeticSizeRadius wrapper method implementations
//

double IAgGeodeticSizeRadius::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgGeodeticSizeRadius::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgGeodeticSizeRadius::GetRate ( ) {
    double _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgGeodeticSizeRadius::PutRate ( double pVal ) {
    HRESULT _hr = put_Rate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgOrbitStateGeodetic wrapper method implementations
//

enum AgECoordinateSystem _IAgOrbitStateGeodetic::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateGeodetic::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr _IAgOrbitStateGeodetic::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

enum AgEGeodeticSize _IAgOrbitStateGeodetic::GetSizeType ( ) {
    enum AgEGeodeticSize _result;
    HRESULT _hr = get_SizeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateGeodetic::PutSizeType ( enum AgEGeodeticSize pVal ) {
    HRESULT _hr = put_SizeType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgGeodeticSizePtr _IAgOrbitStateGeodetic::GetSize ( ) {
    struct IAgGeodeticSize * _result = 0;
    HRESULT _hr = get_Size(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgGeodeticSizePtr(_result, false);
}

double _IAgOrbitStateGeodetic::GetLatitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Latitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateGeodetic::PutLatitude ( double pVal ) {
    HRESULT _hr = put_Latitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateGeodetic::GetLongitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Longitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateGeodetic::PutLongitude ( double pVal ) {
    HRESULT _hr = put_Longitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateGeodetic::GetLatitudeRate ( ) {
    double _result = 0;
    HRESULT _hr = get_LatitudeRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateGeodetic::PutLatitudeRate ( double pVal ) {
    HRESULT _hr = put_LatitudeRate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateGeodetic::GetLongitudeRate ( ) {
    double _result = 0;
    HRESULT _hr = get_LongitudeRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateGeodetic::PutLongitudeRate ( double pVal ) {
    HRESULT _hr = put_LongitudeRate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * _IAgOrbitStateGeodetic::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgOrbitStatePtr _IAgOrbitStateGeodetic::ConvertTo ( enum AgEOrbitStateType Type ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

enum AgEOrbitStateType _IAgOrbitStateGeodetic::GetOrbitStateType ( ) {
    enum AgEOrbitStateType _result;
    HRESULT _hr = get_OrbitStateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrbitStateGeodetic::Assign ( struct IAgOrbitState * pOrbitState ) {
    HRESULT _hr = raw_Assign(pOrbitState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateGeodetic::AssignClassical ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double Eccentricity, double Inclination, double ArgOfPerigee, double RAAN, double MeanAnomaly ) {
    HRESULT _hr = raw_AssignClassical(ECoordinateSystem, SemiMajorAxis, Eccentricity, Inclination, ArgOfPerigee, RAAN, MeanAnomaly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateGeodetic::AssignCartesian ( enum AgECoordinateSystem ECoordinateSystem, double XPosition, double YPosition, double ZPosition, double XVelocity, double YVelocity, double ZVelocity ) {
    HRESULT _hr = raw_AssignCartesian(ECoordinateSystem, XPosition, YPosition, ZPosition, XVelocity, YVelocity, ZVelocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateGeodetic::AssignGeodetic ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double LatitudeRate, double LongitudeRate, double AltitudeRate ) {
    HRESULT _hr = raw_AssignGeodetic(ECoordinateSystem, Latitude, Longitude, Altitude, LatitudeRate, LongitudeRate, AltitudeRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateGeodetic::AssignEquinoctial ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon, enum AgEEquinoctialFormulation EquinoctialFormulation ) {
    HRESULT _hr = raw_AssignEquinoctial(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon, EquinoctialFormulation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateGeodetic::AssignMixedSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignMixedSpherical(ECoordinateSystem, Latitude, Longitude, Altitude, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateGeodetic::AssignSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Radius, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignSpherical(ECoordinateSystem, Latitude, Longitude, Radius, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgOrbitStateGeodetic::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t _IAgOrbitStateGeodetic::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrbitStateGeodetic::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgOrbitStateGeodetic wrapper method implementations
//

enum AgECoordinateSystem IAgOrbitStateGeodetic::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateGeodetic::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr IAgOrbitStateGeodetic::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

enum AgEGeodeticSize IAgOrbitStateGeodetic::GetSizeType ( ) {
    enum AgEGeodeticSize _result;
    HRESULT _hr = get_SizeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateGeodetic::PutSizeType ( enum AgEGeodeticSize pVal ) {
    HRESULT _hr = put_SizeType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgGeodeticSizePtr IAgOrbitStateGeodetic::GetSize ( ) {
    struct IAgGeodeticSize * _result = 0;
    HRESULT _hr = get_Size(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgGeodeticSizePtr(_result, false);
}

double IAgOrbitStateGeodetic::GetLatitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Latitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateGeodetic::PutLatitude ( double pVal ) {
    HRESULT _hr = put_Latitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateGeodetic::GetLongitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Longitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateGeodetic::PutLongitude ( double pVal ) {
    HRESULT _hr = put_Longitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateGeodetic::GetLatitudeRate ( ) {
    double _result = 0;
    HRESULT _hr = get_LatitudeRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateGeodetic::PutLatitudeRate ( double pVal ) {
    HRESULT _hr = put_LatitudeRate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateGeodetic::GetLongitudeRate ( ) {
    double _result = 0;
    HRESULT _hr = get_LongitudeRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateGeodetic::PutLongitudeRate ( double pVal ) {
    HRESULT _hr = put_LongitudeRate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IAgOrbitStateGeodetic::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgDelaunayL wrapper method implementations
//

double _IAgDelaunayL::GetL ( ) {
    double _result = 0;
    HRESULT _hr = get_L(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDelaunayL::PutL ( double pVal ) {
    HRESULT _hr = put_L(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgDelaunayL wrapper method implementations
//

double IAgDelaunayL::GetL ( ) {
    double _result = 0;
    HRESULT _hr = get_L(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDelaunayL::PutL ( double pVal ) {
    HRESULT _hr = put_L(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgDelaunayLOverSQRTmu wrapper method implementations
//

double _IAgDelaunayLOverSQRTmu::GetLOverSQRTmu ( ) {
    double _result = 0;
    HRESULT _hr = get_LOverSQRTmu(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDelaunayLOverSQRTmu::PutLOverSQRTmu ( double pVal ) {
    HRESULT _hr = put_LOverSQRTmu(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgDelaunayLOverSQRTmu wrapper method implementations
//

double IAgDelaunayLOverSQRTmu::GetLOverSQRTmu ( ) {
    double _result = 0;
    HRESULT _hr = get_LOverSQRTmu(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDelaunayLOverSQRTmu::PutLOverSQRTmu ( double pVal ) {
    HRESULT _hr = put_LOverSQRTmu(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgDelaunayH wrapper method implementations
//

double _IAgDelaunayH::GetH ( ) {
    double _result = 0;
    HRESULT _hr = get_H(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDelaunayH::PutH ( double pVal ) {
    HRESULT _hr = put_H(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgDelaunayH wrapper method implementations
//

double IAgDelaunayH::GetH ( ) {
    double _result = 0;
    HRESULT _hr = get_H(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDelaunayH::PutH ( double pVal ) {
    HRESULT _hr = put_H(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgDelaunayHOverSQRTmu wrapper method implementations
//

double _IAgDelaunayHOverSQRTmu::GetHOverSQRTmu ( ) {
    double _result = 0;
    HRESULT _hr = get_HOverSQRTmu(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDelaunayHOverSQRTmu::PutHOverSQRTmu ( double pVal ) {
    HRESULT _hr = put_HOverSQRTmu(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgDelaunayHOverSQRTmu wrapper method implementations
//

double IAgDelaunayHOverSQRTmu::GetHOverSQRTmu ( ) {
    double _result = 0;
    HRESULT _hr = get_HOverSQRTmu(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDelaunayHOverSQRTmu::PutHOverSQRTmu ( double pVal ) {
    HRESULT _hr = put_HOverSQRTmu(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgDelaunayG wrapper method implementations
//

double _IAgDelaunayG::GetG ( ) {
    double _result = 0;
    HRESULT _hr = get_G(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDelaunayG::PutG ( double pVal ) {
    HRESULT _hr = put_G(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgDelaunayG wrapper method implementations
//

double IAgDelaunayG::GetG ( ) {
    double _result = 0;
    HRESULT _hr = get_G(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDelaunayG::PutG ( double pVal ) {
    HRESULT _hr = put_G(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgDelaunayGOverSQRTmu wrapper method implementations
//

double _IAgDelaunayGOverSQRTmu::GetGOverSQRTmu ( ) {
    double _result = 0;
    HRESULT _hr = get_GOverSQRTmu(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDelaunayGOverSQRTmu::PutGOverSQRTmu ( double pVal ) {
    HRESULT _hr = put_GOverSQRTmu(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgDelaunayGOverSQRTmu wrapper method implementations
//

double IAgDelaunayGOverSQRTmu::GetGOverSQRTmu ( ) {
    double _result = 0;
    HRESULT _hr = get_GOverSQRTmu(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDelaunayGOverSQRTmu::PutGOverSQRTmu ( double pVal ) {
    HRESULT _hr = put_GOverSQRTmu(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgOrbitStateDelaunay wrapper method implementations
//

enum AgECoordinateSystem _IAgOrbitStateDelaunay::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateDelaunay::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr _IAgOrbitStateDelaunay::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

double _IAgOrbitStateDelaunay::GetiMeanAnomaly ( ) {
    double _result = 0;
    HRESULT _hr = get_iMeanAnomaly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateDelaunay::PutiMeanAnomaly ( double pVal ) {
    HRESULT _hr = put_iMeanAnomaly(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateDelaunay::GetgArgOfPerigee ( ) {
    double _result = 0;
    HRESULT _hr = get_gArgOfPerigee(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateDelaunay::PutgArgOfPerigee ( double pVal ) {
    HRESULT _hr = put_gArgOfPerigee(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateDelaunay::GethRAAN ( ) {
    double _result = 0;
    HRESULT _hr = get_hRAAN(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateDelaunay::PuthRAAN ( double pVal ) {
    HRESULT _hr = put_hRAAN(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEDelaunayLType _IAgOrbitStateDelaunay::GetLType ( ) {
    enum AgEDelaunayLType _result;
    HRESULT _hr = get_LType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateDelaunay::PutLType ( enum AgEDelaunayLType pVal ) {
    HRESULT _hr = put_LType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgDelaunayActionVariablePtr _IAgOrbitStateDelaunay::GetL ( ) {
    struct IAgDelaunayActionVariable * _result = 0;
    HRESULT _hr = get_L(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDelaunayActionVariablePtr(_result, false);
}

enum AgEDelaunayHType _IAgOrbitStateDelaunay::GetHType ( ) {
    enum AgEDelaunayHType _result;
    HRESULT _hr = get_HType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateDelaunay::PutHType ( enum AgEDelaunayHType pVal ) {
    HRESULT _hr = put_HType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgDelaunayActionVariablePtr _IAgOrbitStateDelaunay::GetH ( ) {
    struct IAgDelaunayActionVariable * _result = 0;
    HRESULT _hr = get_H(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDelaunayActionVariablePtr(_result, false);
}

enum AgEDelaunayGType _IAgOrbitStateDelaunay::GetGType ( ) {
    enum AgEDelaunayGType _result;
    HRESULT _hr = get_GType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateDelaunay::PutGType ( enum AgEDelaunayGType pVal ) {
    HRESULT _hr = put_GType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgDelaunayActionVariablePtr _IAgOrbitStateDelaunay::GetG ( ) {
    struct IAgDelaunayActionVariable * _result = 0;
    HRESULT _hr = get_G(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDelaunayActionVariablePtr(_result, false);
}

SAFEARRAY * _IAgOrbitStateDelaunay::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgOrbitStatePtr _IAgOrbitStateDelaunay::ConvertTo ( enum AgEOrbitStateType Type ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

enum AgEOrbitStateType _IAgOrbitStateDelaunay::GetOrbitStateType ( ) {
    enum AgEOrbitStateType _result;
    HRESULT _hr = get_OrbitStateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrbitStateDelaunay::Assign ( struct IAgOrbitState * pOrbitState ) {
    HRESULT _hr = raw_Assign(pOrbitState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateDelaunay::AssignClassical ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double Eccentricity, double Inclination, double ArgOfPerigee, double RAAN, double MeanAnomaly ) {
    HRESULT _hr = raw_AssignClassical(ECoordinateSystem, SemiMajorAxis, Eccentricity, Inclination, ArgOfPerigee, RAAN, MeanAnomaly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateDelaunay::AssignCartesian ( enum AgECoordinateSystem ECoordinateSystem, double XPosition, double YPosition, double ZPosition, double XVelocity, double YVelocity, double ZVelocity ) {
    HRESULT _hr = raw_AssignCartesian(ECoordinateSystem, XPosition, YPosition, ZPosition, XVelocity, YVelocity, ZVelocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateDelaunay::AssignGeodetic ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double LatitudeRate, double LongitudeRate, double AltitudeRate ) {
    HRESULT _hr = raw_AssignGeodetic(ECoordinateSystem, Latitude, Longitude, Altitude, LatitudeRate, LongitudeRate, AltitudeRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateDelaunay::AssignEquinoctial ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon, enum AgEEquinoctialFormulation EquinoctialFormulation ) {
    HRESULT _hr = raw_AssignEquinoctial(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon, EquinoctialFormulation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateDelaunay::AssignMixedSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignMixedSpherical(ECoordinateSystem, Latitude, Longitude, Altitude, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateDelaunay::AssignSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Radius, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignSpherical(ECoordinateSystem, Latitude, Longitude, Radius, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgOrbitStateDelaunay::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t _IAgOrbitStateDelaunay::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrbitStateDelaunay::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateDelaunay::GetMeanAnomaly ( ) {
    double _result = 0;
    HRESULT _hr = get_MeanAnomaly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateDelaunay::PutMeanAnomaly ( double pVal ) {
    HRESULT _hr = put_MeanAnomaly(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateDelaunay::GetArgOfPeriapsis ( ) {
    double _result = 0;
    HRESULT _hr = get_ArgOfPeriapsis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateDelaunay::PutArgOfPeriapsis ( double pVal ) {
    HRESULT _hr = put_ArgOfPeriapsis(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateDelaunay::GetRAAN ( ) {
    double _result = 0;
    HRESULT _hr = get_RAAN(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateDelaunay::PutRAAN ( double pVal ) {
    HRESULT _hr = put_RAAN(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgOrbitStateDelaunay wrapper method implementations
//

enum AgECoordinateSystem IAgOrbitStateDelaunay::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateDelaunay::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr IAgOrbitStateDelaunay::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

double IAgOrbitStateDelaunay::GetiMeanAnomaly ( ) {
    double _result = 0;
    HRESULT _hr = get_iMeanAnomaly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateDelaunay::PutiMeanAnomaly ( double pVal ) {
    HRESULT _hr = put_iMeanAnomaly(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateDelaunay::GetgArgOfPerigee ( ) {
    double _result = 0;
    HRESULT _hr = get_gArgOfPerigee(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateDelaunay::PutgArgOfPerigee ( double pVal ) {
    HRESULT _hr = put_gArgOfPerigee(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateDelaunay::GethRAAN ( ) {
    double _result = 0;
    HRESULT _hr = get_hRAAN(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateDelaunay::PuthRAAN ( double pVal ) {
    HRESULT _hr = put_hRAAN(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEDelaunayLType IAgOrbitStateDelaunay::GetLType ( ) {
    enum AgEDelaunayLType _result;
    HRESULT _hr = get_LType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateDelaunay::PutLType ( enum AgEDelaunayLType pVal ) {
    HRESULT _hr = put_LType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgDelaunayActionVariablePtr IAgOrbitStateDelaunay::GetL ( ) {
    struct IAgDelaunayActionVariable * _result = 0;
    HRESULT _hr = get_L(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDelaunayActionVariablePtr(_result, false);
}

enum AgEDelaunayHType IAgOrbitStateDelaunay::GetHType ( ) {
    enum AgEDelaunayHType _result;
    HRESULT _hr = get_HType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateDelaunay::PutHType ( enum AgEDelaunayHType pVal ) {
    HRESULT _hr = put_HType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgDelaunayActionVariablePtr IAgOrbitStateDelaunay::GetH ( ) {
    struct IAgDelaunayActionVariable * _result = 0;
    HRESULT _hr = get_H(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDelaunayActionVariablePtr(_result, false);
}

enum AgEDelaunayGType IAgOrbitStateDelaunay::GetGType ( ) {
    enum AgEDelaunayGType _result;
    HRESULT _hr = get_GType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateDelaunay::PutGType ( enum AgEDelaunayGType pVal ) {
    HRESULT _hr = put_GType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgDelaunayActionVariablePtr IAgOrbitStateDelaunay::GetG ( ) {
    struct IAgDelaunayActionVariable * _result = 0;
    HRESULT _hr = get_G(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDelaunayActionVariablePtr(_result, false);
}

SAFEARRAY * IAgOrbitStateDelaunay::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double IAgOrbitStateDelaunay::GetMeanAnomaly ( ) {
    double _result = 0;
    HRESULT _hr = get_MeanAnomaly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateDelaunay::PutMeanAnomaly ( double pVal ) {
    HRESULT _hr = put_MeanAnomaly(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateDelaunay::GetArgOfPeriapsis ( ) {
    double _result = 0;
    HRESULT _hr = get_ArgOfPeriapsis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateDelaunay::PutArgOfPeriapsis ( double pVal ) {
    HRESULT _hr = put_ArgOfPeriapsis(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateDelaunay::GetRAAN ( ) {
    double _result = 0;
    HRESULT _hr = get_RAAN(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateDelaunay::PutRAAN ( double pVal ) {
    HRESULT _hr = put_RAAN(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgEquinoctialSizeShapeMeanMotion wrapper method implementations
//

double _IAgEquinoctialSizeShapeMeanMotion::GetMeanMotion ( ) {
    double _result = 0;
    HRESULT _hr = get_MeanMotion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgEquinoctialSizeShapeMeanMotion::PutMeanMotion ( double pVal ) {
    HRESULT _hr = put_MeanMotion(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgEquinoctialSizeShapeMeanMotion wrapper method implementations
//

double IAgEquinoctialSizeShapeMeanMotion::GetMeanMotion ( ) {
    double _result = 0;
    HRESULT _hr = get_MeanMotion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgEquinoctialSizeShapeMeanMotion::PutMeanMotion ( double pVal ) {
    HRESULT _hr = put_MeanMotion(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgEquinoctialSizeShapeSemimajorAxis wrapper method implementations
//

double _IAgEquinoctialSizeShapeSemimajorAxis::GetSemiMajorAxis ( ) {
    double _result = 0;
    HRESULT _hr = get_SemiMajorAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgEquinoctialSizeShapeSemimajorAxis::PutSemiMajorAxis ( double pVal ) {
    HRESULT _hr = put_SemiMajorAxis(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgEquinoctialSizeShapeSemimajorAxis wrapper method implementations
//

double IAgEquinoctialSizeShapeSemimajorAxis::GetSemiMajorAxis ( ) {
    double _result = 0;
    HRESULT _hr = get_SemiMajorAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgEquinoctialSizeShapeSemimajorAxis::PutSemiMajorAxis ( double pVal ) {
    HRESULT _hr = put_SemiMajorAxis(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgOrbitStateEquinoctial wrapper method implementations
//

enum AgECoordinateSystem _IAgOrbitStateEquinoctial::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateEquinoctial::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr _IAgOrbitStateEquinoctial::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

enum AgEEquinoctialSizeShape _IAgOrbitStateEquinoctial::GetSizeShapeType ( ) {
    enum AgEEquinoctialSizeShape _result;
    HRESULT _hr = get_SizeShapeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateEquinoctial::PutSizeShapeType ( enum AgEEquinoctialSizeShape pVal ) {
    HRESULT _hr = put_SizeShapeType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgClassicalSizeShapePtr _IAgOrbitStateEquinoctial::GetSizeShape ( ) {
    struct IAgClassicalSizeShape * _result = 0;
    HRESULT _hr = get_SizeShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgClassicalSizeShapePtr(_result, false);
}

double _IAgOrbitStateEquinoctial::GetH ( ) {
    double _result = 0;
    HRESULT _hr = get_H(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateEquinoctial::PutH ( double pVal ) {
    HRESULT _hr = put_H(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateEquinoctial::GetK ( ) {
    double _result = 0;
    HRESULT _hr = get_K(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateEquinoctial::PutK ( double pVal ) {
    HRESULT _hr = put_K(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateEquinoctial::GetP ( ) {
    double _result = 0;
    HRESULT _hr = get_P(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateEquinoctial::PutP ( double pVal ) {
    HRESULT _hr = put_P(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateEquinoctial::GetQ ( ) {
    double _result = 0;
    HRESULT _hr = get_Q(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateEquinoctial::PutQ ( double pVal ) {
    HRESULT _hr = put_Q(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateEquinoctial::GetMeanLongitude ( ) {
    double _result = 0;
    HRESULT _hr = get_MeanLongitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateEquinoctial::PutMeanLongitude ( double pVal ) {
    HRESULT _hr = put_MeanLongitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEEquinoctialFormulation _IAgOrbitStateEquinoctial::GetFormulation ( ) {
    enum AgEEquinoctialFormulation _result;
    HRESULT _hr = get_Formulation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateEquinoctial::PutFormulation ( enum AgEEquinoctialFormulation pVal ) {
    HRESULT _hr = put_Formulation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * _IAgOrbitStateEquinoctial::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgOrbitStatePtr _IAgOrbitStateEquinoctial::ConvertTo ( enum AgEOrbitStateType Type ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

enum AgEOrbitStateType _IAgOrbitStateEquinoctial::GetOrbitStateType ( ) {
    enum AgEOrbitStateType _result;
    HRESULT _hr = get_OrbitStateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrbitStateEquinoctial::Assign ( struct IAgOrbitState * pOrbitState ) {
    HRESULT _hr = raw_Assign(pOrbitState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateEquinoctial::AssignClassical ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double Eccentricity, double Inclination, double ArgOfPerigee, double RAAN, double MeanAnomaly ) {
    HRESULT _hr = raw_AssignClassical(ECoordinateSystem, SemiMajorAxis, Eccentricity, Inclination, ArgOfPerigee, RAAN, MeanAnomaly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateEquinoctial::AssignCartesian ( enum AgECoordinateSystem ECoordinateSystem, double XPosition, double YPosition, double ZPosition, double XVelocity, double YVelocity, double ZVelocity ) {
    HRESULT _hr = raw_AssignCartesian(ECoordinateSystem, XPosition, YPosition, ZPosition, XVelocity, YVelocity, ZVelocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateEquinoctial::AssignGeodetic ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double LatitudeRate, double LongitudeRate, double AltitudeRate ) {
    HRESULT _hr = raw_AssignGeodetic(ECoordinateSystem, Latitude, Longitude, Altitude, LatitudeRate, LongitudeRate, AltitudeRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateEquinoctial::AssignEquinoctial ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon, enum AgEEquinoctialFormulation EquinoctialFormulation ) {
    HRESULT _hr = raw_AssignEquinoctial(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon, EquinoctialFormulation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateEquinoctial::AssignMixedSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignMixedSpherical(ECoordinateSystem, Latitude, Longitude, Altitude, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateEquinoctial::AssignSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Radius, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignSpherical(ECoordinateSystem, Latitude, Longitude, Radius, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgOrbitStateEquinoctial::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t _IAgOrbitStateEquinoctial::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrbitStateEquinoctial::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgOrbitStateEquinoctial wrapper method implementations
//

enum AgECoordinateSystem IAgOrbitStateEquinoctial::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateEquinoctial::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr IAgOrbitStateEquinoctial::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

enum AgEEquinoctialSizeShape IAgOrbitStateEquinoctial::GetSizeShapeType ( ) {
    enum AgEEquinoctialSizeShape _result;
    HRESULT _hr = get_SizeShapeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateEquinoctial::PutSizeShapeType ( enum AgEEquinoctialSizeShape pVal ) {
    HRESULT _hr = put_SizeShapeType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgClassicalSizeShapePtr IAgOrbitStateEquinoctial::GetSizeShape ( ) {
    struct IAgClassicalSizeShape * _result = 0;
    HRESULT _hr = get_SizeShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgClassicalSizeShapePtr(_result, false);
}

double IAgOrbitStateEquinoctial::GetH ( ) {
    double _result = 0;
    HRESULT _hr = get_H(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateEquinoctial::PutH ( double pVal ) {
    HRESULT _hr = put_H(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateEquinoctial::GetK ( ) {
    double _result = 0;
    HRESULT _hr = get_K(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateEquinoctial::PutK ( double pVal ) {
    HRESULT _hr = put_K(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateEquinoctial::GetP ( ) {
    double _result = 0;
    HRESULT _hr = get_P(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateEquinoctial::PutP ( double pVal ) {
    HRESULT _hr = put_P(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateEquinoctial::GetQ ( ) {
    double _result = 0;
    HRESULT _hr = get_Q(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateEquinoctial::PutQ ( double pVal ) {
    HRESULT _hr = put_Q(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateEquinoctial::GetMeanLongitude ( ) {
    double _result = 0;
    HRESULT _hr = get_MeanLongitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateEquinoctial::PutMeanLongitude ( double pVal ) {
    HRESULT _hr = put_MeanLongitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEEquinoctialFormulation IAgOrbitStateEquinoctial::GetFormulation ( ) {
    enum AgEEquinoctialFormulation _result;
    HRESULT _hr = get_Formulation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateEquinoctial::PutFormulation ( enum AgEEquinoctialFormulation pVal ) {
    HRESULT _hr = put_Formulation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IAgOrbitStateEquinoctial::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgMixedSphericalFPAHorizontal wrapper method implementations
//

double _IAgMixedSphericalFPAHorizontal::GetFPA ( ) {
    double _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgMixedSphericalFPAHorizontal::PutFPA ( double pVal ) {
    HRESULT _hr = put_FPA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgMixedSphericalFPAHorizontal wrapper method implementations
//

double IAgMixedSphericalFPAHorizontal::GetFPA ( ) {
    double _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgMixedSphericalFPAHorizontal::PutFPA ( double pVal ) {
    HRESULT _hr = put_FPA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgMixedSphericalFPAVertical wrapper method implementations
//

double _IAgMixedSphericalFPAVertical::GetFPA ( ) {
    double _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgMixedSphericalFPAVertical::PutFPA ( double pVal ) {
    HRESULT _hr = put_FPA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgMixedSphericalFPAVertical wrapper method implementations
//

double IAgMixedSphericalFPAVertical::GetFPA ( ) {
    double _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgMixedSphericalFPAVertical::PutFPA ( double pVal ) {
    HRESULT _hr = put_FPA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgOrbitStateMixedSpherical wrapper method implementations
//

enum AgECoordinateSystem _IAgOrbitStateMixedSpherical::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateMixedSpherical::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr _IAgOrbitStateMixedSpherical::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

double _IAgOrbitStateMixedSpherical::GetLatitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Latitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateMixedSpherical::PutLatitude ( double pVal ) {
    HRESULT _hr = put_Latitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateMixedSpherical::GetLongitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Longitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateMixedSpherical::PutLongitude ( double pVal ) {
    HRESULT _hr = put_Longitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateMixedSpherical::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateMixedSpherical::PutAltitude ( double pVal ) {
    HRESULT _hr = put_Altitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEMixedSphericalFPA _IAgOrbitStateMixedSpherical::GetFPAType ( ) {
    enum AgEMixedSphericalFPA _result;
    HRESULT _hr = get_FPAType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateMixedSpherical::PutFPAType ( enum AgEMixedSphericalFPA pVal ) {
    HRESULT _hr = put_FPAType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgFlightPathAnglePtr _IAgOrbitStateMixedSpherical::GetFPA ( ) {
    struct IAgFlightPathAngle * _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgFlightPathAnglePtr(_result, false);
}

double _IAgOrbitStateMixedSpherical::GetAzimuth ( ) {
    double _result = 0;
    HRESULT _hr = get_Azimuth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateMixedSpherical::PutAzimuth ( double pVal ) {
    HRESULT _hr = put_Azimuth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateMixedSpherical::GetVelocity ( ) {
    double _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateMixedSpherical::PutVelocity ( double pVal ) {
    HRESULT _hr = put_Velocity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * _IAgOrbitStateMixedSpherical::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgOrbitStatePtr _IAgOrbitStateMixedSpherical::ConvertTo ( enum AgEOrbitStateType Type ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

enum AgEOrbitStateType _IAgOrbitStateMixedSpherical::GetOrbitStateType ( ) {
    enum AgEOrbitStateType _result;
    HRESULT _hr = get_OrbitStateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrbitStateMixedSpherical::Assign ( struct IAgOrbitState * pOrbitState ) {
    HRESULT _hr = raw_Assign(pOrbitState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateMixedSpherical::AssignClassical ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double Eccentricity, double Inclination, double ArgOfPerigee, double RAAN, double MeanAnomaly ) {
    HRESULT _hr = raw_AssignClassical(ECoordinateSystem, SemiMajorAxis, Eccentricity, Inclination, ArgOfPerigee, RAAN, MeanAnomaly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateMixedSpherical::AssignCartesian ( enum AgECoordinateSystem ECoordinateSystem, double XPosition, double YPosition, double ZPosition, double XVelocity, double YVelocity, double ZVelocity ) {
    HRESULT _hr = raw_AssignCartesian(ECoordinateSystem, XPosition, YPosition, ZPosition, XVelocity, YVelocity, ZVelocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateMixedSpherical::AssignGeodetic ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double LatitudeRate, double LongitudeRate, double AltitudeRate ) {
    HRESULT _hr = raw_AssignGeodetic(ECoordinateSystem, Latitude, Longitude, Altitude, LatitudeRate, LongitudeRate, AltitudeRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateMixedSpherical::AssignEquinoctial ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon, enum AgEEquinoctialFormulation EquinoctialFormulation ) {
    HRESULT _hr = raw_AssignEquinoctial(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon, EquinoctialFormulation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateMixedSpherical::AssignMixedSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignMixedSpherical(ECoordinateSystem, Latitude, Longitude, Altitude, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateMixedSpherical::AssignSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Radius, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignSpherical(ECoordinateSystem, Latitude, Longitude, Radius, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgOrbitStateMixedSpherical::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t _IAgOrbitStateMixedSpherical::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrbitStateMixedSpherical::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgOrbitStateMixedSpherical wrapper method implementations
//

enum AgECoordinateSystem IAgOrbitStateMixedSpherical::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateMixedSpherical::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr IAgOrbitStateMixedSpherical::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

double IAgOrbitStateMixedSpherical::GetLatitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Latitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateMixedSpherical::PutLatitude ( double pVal ) {
    HRESULT _hr = put_Latitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateMixedSpherical::GetLongitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Longitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateMixedSpherical::PutLongitude ( double pVal ) {
    HRESULT _hr = put_Longitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateMixedSpherical::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateMixedSpherical::PutAltitude ( double pVal ) {
    HRESULT _hr = put_Altitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEMixedSphericalFPA IAgOrbitStateMixedSpherical::GetFPAType ( ) {
    enum AgEMixedSphericalFPA _result;
    HRESULT _hr = get_FPAType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateMixedSpherical::PutFPAType ( enum AgEMixedSphericalFPA pVal ) {
    HRESULT _hr = put_FPAType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgFlightPathAnglePtr IAgOrbitStateMixedSpherical::GetFPA ( ) {
    struct IAgFlightPathAngle * _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgFlightPathAnglePtr(_result, false);
}

double IAgOrbitStateMixedSpherical::GetAzimuth ( ) {
    double _result = 0;
    HRESULT _hr = get_Azimuth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateMixedSpherical::PutAzimuth ( double pVal ) {
    HRESULT _hr = put_Azimuth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateMixedSpherical::GetVelocity ( ) {
    double _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateMixedSpherical::PutVelocity ( double pVal ) {
    HRESULT _hr = put_Velocity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IAgOrbitStateMixedSpherical::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgSphericalFPAHorizontal wrapper method implementations
//

double _IAgSphericalFPAHorizontal::GetFPA ( ) {
    double _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgSphericalFPAHorizontal::PutFPA ( double pVal ) {
    HRESULT _hr = put_FPA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgSphericalFPAHorizontal wrapper method implementations
//

double IAgSphericalFPAHorizontal::GetFPA ( ) {
    double _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgSphericalFPAHorizontal::PutFPA ( double pVal ) {
    HRESULT _hr = put_FPA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgSphericalFPAVertical wrapper method implementations
//

double _IAgSphericalFPAVertical::GetFPA ( ) {
    double _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgSphericalFPAVertical::PutFPA ( double pVal ) {
    HRESULT _hr = put_FPA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgSphericalFPAVertical wrapper method implementations
//

double IAgSphericalFPAVertical::GetFPA ( ) {
    double _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgSphericalFPAVertical::PutFPA ( double pVal ) {
    HRESULT _hr = put_FPA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgOrbitStateSpherical wrapper method implementations
//

enum AgECoordinateSystem _IAgOrbitStateSpherical::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateSpherical::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr _IAgOrbitStateSpherical::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

double _IAgOrbitStateSpherical::GetRightAscension ( ) {
    double _result = 0;
    HRESULT _hr = get_RightAscension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateSpherical::PutRightAscension ( double pVal ) {
    HRESULT _hr = put_RightAscension(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateSpherical::GetDeclination ( ) {
    double _result = 0;
    HRESULT _hr = get_Declination(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateSpherical::PutDeclination ( double pVal ) {
    HRESULT _hr = put_Declination(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateSpherical::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateSpherical::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgESphericalFPA _IAgOrbitStateSpherical::GetFPAType ( ) {
    enum AgESphericalFPA _result;
    HRESULT _hr = get_FPAType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateSpherical::PutFPAType ( enum AgESphericalFPA pVal ) {
    HRESULT _hr = put_FPAType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgFlightPathAnglePtr _IAgOrbitStateSpherical::GetFPA ( ) {
    struct IAgFlightPathAngle * _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgFlightPathAnglePtr(_result, false);
}

double _IAgOrbitStateSpherical::GetAzimuth ( ) {
    double _result = 0;
    HRESULT _hr = get_Azimuth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateSpherical::PutAzimuth ( double pVal ) {
    HRESULT _hr = put_Azimuth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrbitStateSpherical::GetVelocity ( ) {
    double _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrbitStateSpherical::PutVelocity ( double pVal ) {
    HRESULT _hr = put_Velocity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * _IAgOrbitStateSpherical::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgOrbitStatePtr _IAgOrbitStateSpherical::ConvertTo ( enum AgEOrbitStateType Type ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

enum AgEOrbitStateType _IAgOrbitStateSpherical::GetOrbitStateType ( ) {
    enum AgEOrbitStateType _result;
    HRESULT _hr = get_OrbitStateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrbitStateSpherical::Assign ( struct IAgOrbitState * pOrbitState ) {
    HRESULT _hr = raw_Assign(pOrbitState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateSpherical::AssignClassical ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double Eccentricity, double Inclination, double ArgOfPerigee, double RAAN, double MeanAnomaly ) {
    HRESULT _hr = raw_AssignClassical(ECoordinateSystem, SemiMajorAxis, Eccentricity, Inclination, ArgOfPerigee, RAAN, MeanAnomaly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateSpherical::AssignCartesian ( enum AgECoordinateSystem ECoordinateSystem, double XPosition, double YPosition, double ZPosition, double XVelocity, double YVelocity, double ZVelocity ) {
    HRESULT _hr = raw_AssignCartesian(ECoordinateSystem, XPosition, YPosition, ZPosition, XVelocity, YVelocity, ZVelocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateSpherical::AssignGeodetic ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double LatitudeRate, double LongitudeRate, double AltitudeRate ) {
    HRESULT _hr = raw_AssignGeodetic(ECoordinateSystem, Latitude, Longitude, Altitude, LatitudeRate, LongitudeRate, AltitudeRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateSpherical::AssignEquinoctial ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon, enum AgEEquinoctialFormulation EquinoctialFormulation ) {
    HRESULT _hr = raw_AssignEquinoctial(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon, EquinoctialFormulation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateSpherical::AssignMixedSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignMixedSpherical(ECoordinateSystem, Latitude, Longitude, Altitude, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitStateSpherical::AssignSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Radius, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignSpherical(ECoordinateSystem, Latitude, Longitude, Radius, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgOrbitStateSpherical::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t _IAgOrbitStateSpherical::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrbitStateSpherical::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgOrbitStateSpherical wrapper method implementations
//

enum AgECoordinateSystem IAgOrbitStateSpherical::GetCoordinateSystemType ( ) {
    enum AgECoordinateSystem _result;
    HRESULT _hr = get_CoordinateSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateSpherical::PutCoordinateSystemType ( enum AgECoordinateSystem pVal ) {
    HRESULT _hr = put_CoordinateSystemType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgOrbitStateCoordinateSystemPtr IAgOrbitStateSpherical::GetCoordinateSystem ( ) {
    struct IAgOrbitStateCoordinateSystem * _result = 0;
    HRESULT _hr = get_CoordinateSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStateCoordinateSystemPtr(_result, false);
}

double IAgOrbitStateSpherical::GetRightAscension ( ) {
    double _result = 0;
    HRESULT _hr = get_RightAscension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateSpherical::PutRightAscension ( double pVal ) {
    HRESULT _hr = put_RightAscension(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateSpherical::GetDeclination ( ) {
    double _result = 0;
    HRESULT _hr = get_Declination(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateSpherical::PutDeclination ( double pVal ) {
    HRESULT _hr = put_Declination(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateSpherical::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateSpherical::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgESphericalFPA IAgOrbitStateSpherical::GetFPAType ( ) {
    enum AgESphericalFPA _result;
    HRESULT _hr = get_FPAType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateSpherical::PutFPAType ( enum AgESphericalFPA pVal ) {
    HRESULT _hr = put_FPAType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgFlightPathAnglePtr IAgOrbitStateSpherical::GetFPA ( ) {
    struct IAgFlightPathAngle * _result = 0;
    HRESULT _hr = get_FPA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgFlightPathAnglePtr(_result, false);
}

double IAgOrbitStateSpherical::GetAzimuth ( ) {
    double _result = 0;
    HRESULT _hr = get_Azimuth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateSpherical::PutAzimuth ( double pVal ) {
    HRESULT _hr = put_Azimuth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrbitStateSpherical::GetVelocity ( ) {
    double _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrbitStateSpherical::PutVelocity ( double pVal ) {
    HRESULT _hr = put_Velocity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IAgOrbitStateSpherical::GetSupportedCoordinateSystemTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_SupportedCoordinateSystemTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgDoublesCollection wrapper method implementations
//

double IAgDoublesCollection::GetItem ( long Index ) {
    double _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgDoublesCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IUnknownPtr IAgDoublesCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

HRESULT IAgDoublesCollection::Add ( double Value ) {
    HRESULT _hr = raw_Add(Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDoublesCollection::RemoveAt ( long Index ) {
    HRESULT _hr = raw_RemoveAt(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDoublesCollection::RemoveAll ( ) {
    HRESULT _hr = raw_RemoveAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgDoublesCollection::ToArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ToArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgDoublesCollection::SetAt ( long Index, double Value ) {
    HRESULT _hr = raw_SetAt(Index, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCartesian3Vector wrapper method implementations
//

double _IAgCartesian3Vector::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian3Vector::PutX ( double pRetVal ) {
    HRESULT _hr = put_X(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCartesian3Vector::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian3Vector::PutY ( double pRetVal ) {
    HRESULT _hr = put_Y(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCartesian3Vector::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian3Vector::PutZ ( double pRetVal ) {
    HRESULT _hr = put_Z(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCartesian3Vector::Get ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_Get(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian3Vector::Set ( double X, double Y, double Z ) {
    HRESULT _hr = raw_Set(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCartesian3Vector::ToArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ToArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCartesian2Vector wrapper method implementations
//

double _IAgCartesian2Vector::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian2Vector::PutX ( double pRetVal ) {
    HRESULT _hr = put_X(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCartesian2Vector::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian2Vector::PutY ( double pRetVal ) {
    HRESULT _hr = put_Y(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCartesian2Vector::Get ( double * X, double * Y ) {
    HRESULT _hr = raw_Get(X, Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian2Vector::Set ( double X, double Y ) {
    HRESULT _hr = raw_Set(X, Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCartesian2Vector::ToArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ToArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCartesian2Vector wrapper method implementations
//

double IAgCartesian2Vector::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian2Vector::PutX ( double pRetVal ) {
    HRESULT _hr = put_X(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCartesian2Vector::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian2Vector::PutY ( double pRetVal ) {
    HRESULT _hr = put_Y(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCartesian2Vector::Get ( double * X, double * Y ) {
    HRESULT _hr = raw_Get(X, Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCartesian2Vector::Set ( double X, double Y ) {
    HRESULT _hr = raw_Set(X, Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgCartesian2Vector::ToArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ToArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgPropertyInfo wrapper method implementations
//

_bstr_t IAgPropertyInfo::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

enum AgEPropertyInfoValueType IAgPropertyInfo::GetPropertyType ( ) {
    enum AgEPropertyInfoValueType _result;
    HRESULT _hr = get_PropertyType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IAgPropertyInfo::GetValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

HRESULT IAgPropertyInfo::SetValue ( const _variant_t & PropertyInfo ) {
    HRESULT _hr = raw_SetValue(PropertyInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IAgPropertyInfo::GetHasMin ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasMin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IAgPropertyInfo::GetHasMax ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasMax(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IAgPropertyInfo::GetMin ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Min(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t IAgPropertyInfo::GetMax ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Max(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _IAgPropertyInfo wrapper method implementations
//

_bstr_t _IAgPropertyInfo::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

enum AgEPropertyInfoValueType _IAgPropertyInfo::GetPropertyType ( ) {
    enum AgEPropertyInfoValueType _result;
    HRESULT _hr = get_PropertyType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t _IAgPropertyInfo::GetValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

HRESULT _IAgPropertyInfo::SetValue ( const _variant_t & PropertyInfo ) {
    HRESULT _hr = raw_SetValue(PropertyInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL _IAgPropertyInfo::GetHasMin ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasMin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgPropertyInfo::GetHasMax ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasMax(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t _IAgPropertyInfo::GetMin ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Min(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t _IAgPropertyInfo::GetMax ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Max(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IAgPropertyInfoCollection wrapper method implementations
//

IAgPropertyInfoPtr IAgPropertyInfoCollection::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgPropertyInfo * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPropertyInfoPtr(_result, false);
}

IUnknownPtr IAgPropertyInfoCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long IAgPropertyInfoCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgRuntimeTypeInfo wrapper method implementations
//

IAgPropertyInfoCollectionPtr _IAgRuntimeTypeInfo::GetProperties ( ) {
    struct IAgPropertyInfoCollection * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPropertyInfoCollectionPtr(_result, false);
}

VARIANT_BOOL _IAgRuntimeTypeInfo::GetIsCollection ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCollection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long _IAgRuntimeTypeInfo::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgPropertyInfoPtr _IAgRuntimeTypeInfo::GetItem ( long Index ) {
    struct IAgPropertyInfo * _result = 0;
    HRESULT _hr = raw_GetItem(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPropertyInfoPtr(_result, false);
}

//
// interface IAgRuntimeTypeInfo wrapper method implementations
//

IAgPropertyInfoCollectionPtr IAgRuntimeTypeInfo::GetProperties ( ) {
    struct IAgPropertyInfoCollection * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPropertyInfoCollectionPtr(_result, false);
}

VARIANT_BOOL IAgRuntimeTypeInfo::GetIsCollection ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCollection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgRuntimeTypeInfo::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgPropertyInfoPtr IAgRuntimeTypeInfo::GetItem ( long Index ) {
    struct IAgPropertyInfo * _result = 0;
    HRESULT _hr = raw_GetItem(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPropertyInfoPtr(_result, false);
}

//
// interface _IAgUnitPrefsUnit wrapper method implementations
//

_bstr_t _IAgUnitPrefsUnit::GetFullName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FullName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgUnitPrefsUnit::GetAbbrv ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Abbrv(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long _IAgUnitPrefsUnit::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgUnitPrefsDimPtr _IAgUnitPrefsUnit::GetDimension ( ) {
    struct IAgUnitPrefsDim * _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsDimPtr(_result, false);
}

//
// interface IAgUnitPrefsDim wrapper method implementations
//

long IAgUnitPrefsDim::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgUnitPrefsDim::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgUnitPrefsUnitCollectionPtr IAgUnitPrefsDim::GetAvailableUnits ( ) {
    struct IAgUnitPrefsUnitCollection * _result = 0;
    HRESULT _hr = get_AvailableUnits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsUnitCollectionPtr(_result, false);
}

IAgUnitPrefsUnitPtr IAgUnitPrefsDim::GetCurrentUnit ( ) {
    struct IAgUnitPrefsUnit * _result = 0;
    HRESULT _hr = get_CurrentUnit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsUnitPtr(_result, false);
}

HRESULT IAgUnitPrefsDim::SetCurrentUnit ( _bstr_t UnitAbbrv ) {
    HRESULT _hr = raw_SetCurrentUnit(UnitAbbrv);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgUnitPrefsUnit wrapper method implementations
//

_bstr_t IAgUnitPrefsUnit::GetFullName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FullName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgUnitPrefsUnit::GetAbbrv ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Abbrv(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long IAgUnitPrefsUnit::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgUnitPrefsDimPtr IAgUnitPrefsUnit::GetDimension ( ) {
    struct IAgUnitPrefsDim * _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsDimPtr(_result, false);
}

//
// interface IAgUnitPrefsUnitCollection wrapper method implementations
//

IAgUnitPrefsUnitPtr IAgUnitPrefsUnitCollection::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgUnitPrefsUnit * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsUnitPtr(_result, false);
}

long IAgUnitPrefsUnitCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IUnknownPtr IAgUnitPrefsUnitCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface _IAgUnitPrefsDim wrapper method implementations
//

long _IAgUnitPrefsDim::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgUnitPrefsDim::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgUnitPrefsUnitCollectionPtr _IAgUnitPrefsDim::GetAvailableUnits ( ) {
    struct IAgUnitPrefsUnitCollection * _result = 0;
    HRESULT _hr = get_AvailableUnits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsUnitCollectionPtr(_result, false);
}

IAgUnitPrefsUnitPtr _IAgUnitPrefsDim::GetCurrentUnit ( ) {
    struct IAgUnitPrefsUnit * _result = 0;
    HRESULT _hr = get_CurrentUnit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsUnitPtr(_result, false);
}

HRESULT _IAgUnitPrefsDim::SetCurrentUnit ( _bstr_t UnitAbbrv ) {
    HRESULT _hr = raw_SetCurrentUnit(UnitAbbrv);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgUnitPrefsDimCollection wrapper method implementations
//

IAgUnitPrefsDimPtr IAgUnitPrefsDimCollection::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgUnitPrefsDim * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsDimPtr(_result, false);
}

long IAgUnitPrefsDimCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgUnitPrefsDimCollection::SetCurrentUnit ( _bstr_t Dimension, _bstr_t UnitAbbrv ) {
    HRESULT _hr = raw_SetCurrentUnit(Dimension, UnitAbbrv);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IAgUnitPrefsDimCollection::GetCurrentUnitAbbrv ( const _variant_t & IndexOrDimName ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetCurrentUnitAbbrv(IndexOrDimName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t IAgUnitPrefsDimCollection::GetMissionElapsedTime ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_MissionElapsedTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgUnitPrefsDimCollection::PutMissionElapsedTime ( const _variant_t & pMisElapTime ) {
    HRESULT _hr = put_MissionElapsedTime(pMisElapTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgUnitPrefsDimCollection::GetJulianDateOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_JulianDateOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgUnitPrefsDimCollection::PutJulianDateOffset ( double pJDateOffset ) {
    HRESULT _hr = put_JulianDateOffset(pJDateOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IUnknownPtr IAgUnitPrefsDimCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

HRESULT IAgUnitPrefsDimCollection::ResetUnits ( ) {
    HRESULT _hr = raw_ResetUnits();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

} // namespace STKUtil
